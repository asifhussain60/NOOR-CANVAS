# Issue-82: Participant Session Link Security Vulnerability - GUID Exposure

**Issue ID:** Issue-82  
**Status:** In Progress  
**Priority:** Critical - Security  
**Category:** Security Enhancement  
**Created:** 2025-09-15  

## Security Problem Description

Current participant session links expose sensitive information that creates multiple security vulnerabilities:

**Current Vulnerable Format:**
```
https://localhost:9091/join/5ec82d65-2f89-4c05-91dd-dc9742326937?userGuid=4a3202c6-c6e0-43d0-8bb6-a08adc87c186
```

## Security Vulnerabilities Identified

1. **GUID Exposure**: Both SessionLink ID and User GUID visible in plain text
2. **Predictable Pattern**: URL structure easily reverse-engineered  
3. **Session Hijacking Risk**: Anyone with URL can potentially access session
4. **User Enumeration**: User GUIDs can be harvested for malicious purposes
5. **URL Logging**: Sensitive identifiers logged in web servers, proxies, browsers
6. **URL Sharing**: Long URLs with sensitive data shared via insecure channels

## Proposed Solution: Option C - Short Secure Hash

**Target Format:**
```
Current: https://localhost:9091/join/5ec82d65-2f89-4c05-91dd-dc9742326937?userGuid=4a3202c6-c6e0-43d0-8bb6-a08adc87c186
Proposed: https://localhost:9091/join/P7X9K2M4
```

### Technical Implementation: Human-Friendly Character Set

**Character Set:** `ABCDEFGHIJKLMNPQRSTUVWXYZ23456789` (32 characters)
- **Excluded confusing chars:** 0/O, 1/I for voice/SMS clarity
- **Token Length:** 8 characters
- **Unique Combinations:** ~1 trillion (32^8 = 1,073,741,824,000)
- **Collision Resistance:** Cryptographically secure with uniqueness validation

## Implementation Plan

### 1. Database Schema Enhancement

**New Table: canvas.SecureSessionTokens**
```sql
CREATE TABLE canvas.SecureSessionTokens (
    TokenId UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    TokenHash VARCHAR(8) NOT NULL UNIQUE,
    SessionLinkId UNIQUEIDENTIFIER NOT NULL,
    UserGuid UNIQUEIDENTIFIER NOT NULL,
    CreatedAt DATETIME2 DEFAULT GETUTCDATE(),
    ExpiresAt DATETIME2 NOT NULL,
    IsActive BIT DEFAULT 1,
    AccessCount INT DEFAULT 0,
    LastAccessedAt DATETIME2 NULL,
    CreatedByIp VARCHAR(45) NULL,
    CONSTRAINT FK_SecureTokens_SessionLinks 
        FOREIGN KEY (SessionLinkId) REFERENCES canvas.SessionLinks(SessionLinkId),
    INDEX IX_SecureTokens_TokenHash (TokenHash),
    INDEX IX_SecureTokens_Expiry (ExpiresAt, IsActive)
);
```

### 2. Token Generation Service

**Location:** `SPA/NoorCanvas/Services/SecureTokenService.cs`

```csharp
public class SecureTokenService 
{
    private const string CHARSET = "ABCDEFGHIJKLMNPQRSTUVWXYZ23456789"; // Human-friendly
    private const int TOKEN_LENGTH = 8;
    private readonly CanvasDbContext _context;
    private readonly ILogger<SecureTokenService> _logger;
    
    public async Task<string> GenerateSecureTokenAsync(
        Guid sessionLinkId, 
        Guid userGuid, 
        int validHours = 24)
    {
        string token;
        int attempts = 0;
        const int maxAttempts = 100;
        
        // Ensure token uniqueness
        do {
            token = GenerateRandomToken();
            attempts++;
            if (attempts > maxAttempts) 
                throw new InvalidOperationException("Unable to generate unique token");
        } while (await TokenExistsAsync(token));
        
        // Save to database
        var secureToken = new SecureSessionToken
        {
            TokenHash = token,
            SessionLinkId = sessionLinkId,
            UserGuid = userGuid,
            ExpiresAt = DateTime.UtcNow.AddHours(validHours),
            IsActive = true
        };
        
        _context.SecureSessionTokens.Add(secureToken);
        await _context.SaveChangesAsync();
        
        _logger.LogInformation("NOOR-SECURITY: Generated secure token {Token} for SessionLink {SessionLinkId}", 
            token, sessionLinkId);
        
        return token;
    }
    
    private string GenerateRandomToken()
    {
        using var rng = RandomNumberGenerator.Create();
        var bytes = new byte[TOKEN_LENGTH];
        var result = new StringBuilder(TOKEN_LENGTH);
        
        for (int i = 0; i < TOKEN_LENGTH; i++)
        {
            rng.GetBytes(bytes, i, 1);
            result.Append(CHARSET[bytes[i] % CHARSET.Length]);
        }
        
        return result.ToString();
    }
}
```

### 3. HostProvisioner Integration

**Update:** `Tools/HostProvisioner/HostProvisioner/Program.cs`

```csharp
// Replace current participant URL generation
if (createUser && sessionLink != null)
{
    var secureTokenService = serviceScope.ServiceProvider.GetRequiredService<SecureTokenService>();
    var secureToken = await secureTokenService.GenerateSecureTokenAsync(
        sessionLink.SessionLinkId, 
        user.UserId, 
        validHours: 24);
    
    var participantUrl = $"https://localhost:9091/join/{secureToken}";
    
    Console.WriteLine($"User GUID: {user.UserGuid}");
    Console.WriteLine($"Participant URL: {participantUrl}");
}
```

### 4. URL Route Handler

**Update:** `SPA/NoorCanvas/Controllers/SessionController.cs`

```csharp
[HttpGet("join/{token}")]
public async Task<IActionResult> JoinWithToken(string token)
{
    // Validate token format
    if (string.IsNullOrEmpty(token) || token.Length != 8)
    {
        return BadRequest("Invalid session token format");
    }
    
    // Lookup token in database
    var secureToken = await _context.SecureSessionTokens
        .Include(st => st.SessionLink)
        .Where(st => st.TokenHash == token 
                  && st.IsActive 
                  && st.ExpiresAt > DateTime.UtcNow)
        .FirstOrDefaultAsync();
    
    if (secureToken == null)
    {
        _logger.LogWarning("NOOR-SECURITY: Invalid or expired token access attempt: {Token}", token);
        return NotFound("Session not found or expired");
    }
    
    // Update access tracking
    secureToken.AccessCount++;
    secureToken.LastAccessedAt = DateTime.UtcNow;
    await _context.SaveChangesAsync();
    
    // Redirect to participant registration with secure context
    return RedirectToAction("Register", "Participant", new { 
        sessionId = secureToken.SessionLink.SessionId,
        userGuid = secureToken.UserGuid 
    });
}
```

## Security Benefits

### User Experience Benefits:
✅ **8 characters only** - easy to type, share, remember  
✅ **No confusing characters** - clear over phone/SMS  
✅ **Clean URLs** - professional appearance  
✅ **SMS-friendly** - fits easily in text messages  

### Security Benefits:
✅ **No exposed GUIDs** - completely opaque to users  
✅ **Cryptographically random** - impossible to guess  
✅ **Expirable tokens** - built-in time limits  
✅ **Revocable access** - can be deactivated in database  
✅ **Audit trail** - track usage and access patterns  
✅ **Access control** - fine-grained permissions per token  

### Technical Benefits:
✅ **Fast lookups** - indexed database queries  
✅ **Collision detection** - automatic uniqueness checking  
✅ **Scalable** - 1 trillion+ unique combinations  
✅ **Stateful control** - full token lifecycle management  

## Acceptance Criteria

- [ ] SecureSessionTokens database table created and migrated
- [ ] SecureTokenService implemented with human-friendly character set
- [ ] HostProvisioner generates short tokens instead of GUID-exposed URLs
- [ ] URL route handler `/join/{token}` validates and processes tokens
- [ ] Token expiry and revocation functionality working
- [ ] Access tracking and audit logging implemented
- [ ] All existing functionality preserved (session joining still works)
- [ ] Security testing completed (token uniqueness, expiry, access control)

## Testing Requirements

1. **Token Generation Testing**: Verify uniqueness across 10,000 generated tokens
2. **Expiry Testing**: Confirm expired tokens properly rejected
3. **Access Tracking**: Verify access count and timestamp updates
4. **Security Testing**: Attempt common attack vectors (brute force, enumeration)
5. **Integration Testing**: End-to-end participant joining workflow
6. **Performance Testing**: Database query performance with large token datasets

## Migration Strategy

1. **Phase 1**: Deploy new schema and service (backward compatible)
2. **Phase 2**: Update HostProvisioner to generate both old and new URLs
3. **Phase 3**: Switch to new URL format exclusively
4. **Phase 4**: Remove old GUID-exposed URL support (after validation period)

## Notes

- **Backward Compatibility**: Maintain existing GUID-based URLs during transition
- **Performance**: Index on TokenHash for O(1) lookup performance  
- **Security**: Consider rate limiting on `/join/{token}` endpoint
- **Monitoring**: Log all token access attempts for security analysis
