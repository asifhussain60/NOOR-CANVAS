------

mode: agentmode: agent

name: pwgentestname: pwgen# Mission

description: Generate production-ready Playwright E2E tests for NOOR Canvas with proven Blazor Server patterns. Includes deep workflow analysis and battle-tested button enablement solutions.

arguments:Generate a **TypeScript** Playwright test for NOOR Canvas that implements **PROVEN SUCCESSFUL PATTERNS** from our testing experience:

  - name: name

    description: Test name (used for filename and test suite)## üéØ **CRITICAL SUCCESS PATTERNS (Based on Working Tests)**:

    required: true- **Blazor Server Button Enablement**: Use `dispatchEvent('input')` and `dispatchEvent('change')` after `.fill()` to trigger `@bind-Value` updates

  - name: targets- **Button State Verification**: Always `await expect(button).toBeEnabled()` before clicking

    description: Files to analyze (Razor pages, components, controllers, routes) - perform deep component analysis- **Database Integration**: Use `DatabaseTokenManager.getPermanentTestSession()` for reliable Session 212 tokens (VNBPRVII/DPH42JR5)

    required: true- **Application Health**: Handle application startup/shutdown gracefully with `EnhancedTestMonitor`

  - name: notes- **Realistic Timing**: 2-second waits for Blazor binding, 18-second application startup tolerance

    description: Additional requirements (edge cases, multi-user scenarios, performance thresholds)

    required: false## üèóÔ∏è **Technical Requirements**:

---- Runs **headless** with rich debug artifacts via `playwright.config.js`

- Uses **sequential execution** (no parallel conflicts)  

# üéØ Mission: Generate Battle-Tested NOOR Canvas E2E Tests- Relies on **global setup/teardown** and **webServer launcher** (nc.ps1)

- **NO manual application startup** in tests

Create a **TypeScript Playwright test** with proven patterns that:- Implements **database fallback** patterns for reliabilityescription: Generate a production-ready Playwright E2E test with NOOR Canvas Blazor Server patterns. Must include proper button enablement, database integration, and application stability handling based on proven successful patterns.

- **Runs headless** with comprehensive debug artifacts via `playwright.config.js`arguments:

- **Solves Blazor Server binding issues** (button enablement, form validation)  - name: name

- **Uses reliable database integration** with Session 212 fallback tokens    description: Name of the Playwright test (used for file name and suite title)

- **Handles application lifecycle** gracefully with enhanced monitoring    required: true

- **Works in CI/CD** with retry stability and realistic timeouts  - name: targets

    description: Files (Razor pages/components, controllers, routes) to review to build the test

## üìã Required Analysis Process    required: true

  - name: notes

### **üîç STEP 1: Deep Component Analysis (CRITICAL)**    description: Any extra constraints or scenarios (edge cases, negative paths, multi-user, perf thresholds)

For each file in `${targets}`, extract and document:    required: false

---t

#### **Razor Pages/Components Analysis**name: pwgentest

- **Routes & Navigation**: Extract `@page` directives and routing patternsdescription: Generate a production-ready Playwright E2E test aligned with this repo‚Äôs Playwright configuration. Tests must run headless, emit verbose logs, and capture trace/screenshots/video and reports for debugging.

- **Form Bindings**: Identify ALL `@bind-Value` properties requiring `fillBlazorInput()`arguments:

- **Conditional Logic**: Find `disabled="@(!condition)"` patterns needing enablement verification  - name: name

- **Cascading Elements**: Locate dropdowns/selects populated after other field changes    description: Name of the Playwright test (used for file name and suite title)

- **SignalR Integration**: Document real-time updates and state synchronization    required: true

- **Validation Rules**: Extract `[Required]`, `[StringLength]`, custom validators  - name: targets

    description: Files (Razor pages/components, controllers, routes) to review to build the test

#### **Controller/API Analysis**      required: true

- **Endpoints**: Document action methods and expected HTTP responses  - name: notes

- **Authorization**: Identify `[Authorize]` requirements and token dependencies    description: Any extra constraints or scenarios (edge cases, negative paths, multi-user, perf thresholds)

- **Model Binding**: Extract input DTOs and validation requirements    required: false

- **Error Handling**: Document exception responses for negative test cases---

- **Database Operations**: Identify session/token queries for test data setup

# Mission

#### **Workflow Mapping**

- **User Journey**: Map complete navigation flow from entry to completionGenerate a **TypeScript** Playwright test for the NOOR Canvas app that:

- **State Dependencies**: Document required application state for each step- Runs **headless** and produces **rich debug artifacts** (trace on first retry, screenshots & videos on failure, HTML + JSON reports) via the project‚Äôs `playwright.config.js`.

- **Critical Paths**: Identify must-work scenarios for business functionality- Emits **verbose Playwright logs** (the runner will set `DEBUG="pw:api,pw:test"`).

- **Error Scenarios**: Map validation failures and error states- Obeys **sequential, single-worker** semantics and relies on the repo‚Äôs **global setup/teardown** and **webServer** launcher. Do **not** attempt to boot the app in the test.

- Implements **Blazor Server binding** so button enablement and validation work reliably in CI.

---

## Inputs

# üö® Proven Technical Patterns (Battle-Tested Solutions)

- **NAME**: ${name}

## **‚úÖ Blazor Server Input Binding (FIXES BUTTON BUGS)**- **TARGETS**: ${targets}

```ts- **NOTES** (optional): ${notes}

/**

 * CRITICAL: Blazor Server requires explicit DOM events for @bind-Value updates## Output

 * This pattern SOLVES button enablement issues that plagued previous tests

 */- **File**: `PlayWright/tests/{kebab-case(NAME)}.spec.ts`

async function fillBlazorInput(page: Page, selector: string, value: string) {- **Structure**:

  const input = page.locator(selector);  - Header comment with brief description + date

  await input.clear();                    // Clear existing  - `test.describe('{NAME} ‚Äì summary', () => { ... })`

  await input.fill(value);               // Fill new value  - One or more `test('does X', async ({ page }) => { ... })` blocks

  await input.dispatchEvent('input');    // CRITICAL: Notify Blazor of change- **No global side-effects**; tests must be retry-safe.

  await input.dispatchEvent('change');   // CRITICAL: Trigger validation

  await page.waitForTimeout(2000);       // PROVEN: Wait for Blazor processing---

}

# üö® **MANDATORY BLAZOR PATTERNS (Proven Working)**

async function verifyButtonEnabled(page: Page, selector: string, timeout = 5000) {

  await expect(page.locator(selector)).toBeEnabled({ timeout });## **‚úÖ CRITICAL: Blazor Server Input Binding (FIXES BUTTON ENABLEMENT BUGS)**

}

```**Problem Solved**: Playwright `.fill()` does NOT trigger Blazor `@bind-Value` updates, causing buttons to remain disabled

**Our Solution**: Proven pattern from `host-experience-complete-workflow.spec.ts` success:

## **‚úÖ Database Integration (Reliable Session 212 Fallback)**

```ts```ts

import { DatabaseTokenManager } from '../../../Tests/UI/database-token-manager.ts';/**

 * MANDATORY: Use this exact pattern for ALL Blazor input fields

// PROVEN: Session 212 tokens are PERMANENT in AHHOME database * This pattern WORKS and fixes button enablement issues

const dbManager = new DatabaseTokenManager(); */

const hostToken = await dbManager.getHostToken();    // Falls back to VNBPRVIIasync function fillBlazorInput(page: Page, selector: string, value: string) {

const userToken = await dbManager.getUserToken();    // Falls back to DPH42JR5  const input = page.locator(selector);

  await input.clear();                    // Clear existing value

// Always validate token format  await input.fill(value);               // Fill new value

expect(hostToken).toMatch(/^[A-Z0-9]{8}$/);  await input.dispatchEvent('input');    // CRITICAL: Notify Blazor of input change

```  await input.dispatchEvent('change');   // CRITICAL: Trigger validation/binding

  await page.waitForTimeout(2000);       // PROVEN: 2000ms wait for Blazor processing

## **‚úÖ Application Health & Startup**}

```ts

test.beforeEach(async ({ page }) => {/**

  // PROVEN: 30s timeout handles ASP.NET Core startup realistically * MANDATORY: Button Enablement Verification Pattern

  await page.goto('http://localhost:9090', {  * NEVER click buttons without verifying they're enabled first

    waitUntil: 'networkidle', */

    timeout: 30000 async function clickEnabledButton(page: Page, buttonSelector: string, timeout: number = 5000) {

  });  const button = page.locator(buttonSelector);

  await expect(page).toHaveTitle(/Noor Canvas|NOOR CANVAS/, { timeout: 10000 });  await expect(button).toBeEnabled({ timeout }); // CRITICAL: Verify before clicking

});  await button.click();

```}



## **‚úÖ Navigation & Workflow Validation**## **‚úÖ APPLICATION STARTUP (Proven Reliable Pattern)**

```ts

// PROVEN: Always verify URL changes and page state**Problem Solved**: Tests failing due to unrealistic application startup expectations  

await page.goto(`/host/control-panel/${hostToken}`);**Our Solution**: Enhanced monitoring with realistic timing from `nc.ps1` launcher:

await expect(page).toHaveURL(new RegExp(`/host/control-panel/${hostToken}`));

await expect(page).toHaveTitle(/Control Panel|Host Dashboard/);```ts

/**

// PROVEN: Modern Playwright locators * PROVEN PATTERN: Application health verification before testing

await page.getByRole('button', { name: 'Access Control Panel' }).click(); * NEVER assume app is ready immediately - use proper health checks

await page.getByLabel('Host Token').fill(hostToken); */

```test.beforeEach(async ({ page }) => {

  // CRITICAL: Wait for enhanced monitoring to confirm app is truly ready

---  await page.goto('http://localhost:9090', { 

    waitUntil: 'networkidle',

# üìù Test Generation Template    timeout: 30000  // PROVEN: 30s timeout for ASP.NET Core startup

  });

## Required Imports & Setup  

```ts  // Verify basic page load succeeded

/**  await expect(page).toHaveTitle(/Noor Canvas|NOOR CANVAS/, { timeout: 10000 });

 * ${name} - Generated E2E Test});

 * Targets: ${targets}```

 * Notes: ${notes}

 * Generated: ${new Date().toISOString().slice(0,10)}## **‚úÖ DATABASE INTEGRATION (Proven Reliable Fallback)**

 */

import { test, expect, type Page } from '@playwright/test';**Problem Solved**: Test failures due to missing sessions in AHHOME database  

import { DatabaseTokenManager } from '../../../Tests/UI/database-token-manager.ts';**Our Solution**: Permanent Session 212 tokens with graceful fallback:

```

```ts

## Test Structure Requirementsimport { DatabaseTokenManager } from '../../../Tests/UI/database-token-manager.ts';

- **File Location**: `PlayWright/tests/{kebab-case(name)}.spec.ts`

- **Test Suite**: `test.describe('${name}', () => { ... })`/**

- **Descriptive Test Names**: Focus on business functionality * PROVEN PATTERN: Real database tokens with reliable fallback

- **beforeEach**: Application health verification * Session 212 tokens are PERMANENT in AHHOME database:

- **Comprehensive Assertions**: URL, title, content, state verification * - Host Token: VNBPRVII (always works)

 * - User Token: DPH42JR5 (always works)  

## Quality Checklist */

- [ ] `fillBlazorInput()` used for ALL form inputsconst dbManager = new DatabaseTokenManager();

- [ ] Button enablement verified before clickingconst hostToken = await dbManager.getHostToken();   // Falls back to VNBPRVII if DB unavailable

- [ ] Database tokens with fallback patternsconst userToken = await dbManager.getUserToken();   // Falls back to DPH42JR5 if DB unavailable

- [ ] Navigation verified with URL assertions

- [ ] Error scenarios covered based on controller analysis/**

- [ ] Realistic timeouts (2s Blazor, 30s startup, 10s expects) * CRITICAL: Always verify tokens are valid 8-character format

- [ ] Security-safe logging (no token exposure) */

- [ ] Retry-stable design (no transient dependencies)expect(hostToken).toMatch(/^[A-Z0-9]{8}$/);

expect(userToken).toMatch(/^[A-Z0-9]{8}$/);

---```



# üìñ How This Test Generation Works (Plain English)## **‚ö° MANDATORY TEST PATTERNS (From Working Tests)**



## What This Prompt Does### **Navigation & URL Validation**

This prompt helps GitHub Copilot create **reliable website tests** for the NOOR Canvas application. Think of it as a recipe that ensures every test follows proven patterns that actually work.```ts

// PROVEN: Always verify URL changes after navigation

## Why These Patterns Matterawait page.goto(`/host/control-panel/${hostToken}`);

**The Problem**: Regular web testing tools don't work well with Blazor Server (the technology NOOR Canvas uses) because Blazor has special requirements for form inputs and button interactions.await expect(page).toHaveURL(new RegExp(`/host/control-panel/${hostToken}`));

await expect(page).toHaveTitle(/Control Panel|Host Dashboard/, { timeout: 10000 });

**Our Solution**: We've discovered specific techniques through real testing that solve these problems:```



1. **Form Filling**: Instead of just typing in form fields, we send special "events" that tell Blazor the field changed### **Blazor Form Interaction (CRITICAL)**

2. **Button Clicking**: We always check that buttons are enabled before clicking them```ts

3. **Database Setup**: We use real session tokens from the database, but have backup tokens if the database isn't available// MANDATORY: Use fillBlazorInput for ALL form fields

4. **App Startup**: We wait realistically for the application to fully start (30 seconds) instead of assuming it's ready immediatelyawait fillBlazorInput(page, '#hostTokenInput', hostToken);



## How the Generated Test Works// MANDATORY: Verify button enablement before clicking

1. **Setup Phase**: Connects to the database and gets valid session tokensawait clickEnabledButton(page, 'button:has-text("Access Control Panel")', 10000);

2. **Navigation**: Opens the correct web pages in the right order```

3. **Form Interaction**: Fills out forms using the special Blazor-compatible method

4. **Verification**: Checks that each step worked correctly (right page loaded, buttons enabled, etc.)### **Dropdown Handling (Blazor Cascading)**

5. **Cleanup**: Handles errors gracefully and provides helpful debug information```ts

// PROVEN: Wait for Blazor to populate dropdowns after token validation

## What Makes This Differentawait page.waitForTimeout(3000); // Allow cascading dropdowns to load

- **Battle-Tested**: These patterns come from solving real problems in actual testingconst dropdown = page.locator('select#sessionSelector');

- **Blazor-Aware**: Specifically designed for Blazor Server applications like NOOR Canvas  await expect(dropdown.locator('option')).toHaveCount(gt(1)); // Verify options loaded

- **CI/CD Ready**: Works reliably in automated testing environmentsawait dropdown.selectOption({ index: 1 }); // Select first real option

- **Debug-Friendly**: Captures screenshots, videos, and logs when tests fail```

- **Realistic**: Uses actual timing expectations based on how the application really behaves

### **Enhanced Monitoring Integration**

The result is tests that **actually work** instead of tests that fail for technical reasons unrelated to the application functionality.```ts
// OPTIONAL: Use EnhancedTestMonitor for health checks (non-fatal)
import { EnhancedTestMonitor } from '../../../Tests/UI/enhanced-test-monitor.ts';
const monitor = new EnhancedTestMonitor();
await monitor.ensureApplicationReady(); // Graceful health check
```

## **üéØ PROVEN SUCCESS PATTERNS**

### **Locator Best Practices**
```ts
// PREFERRED: Modern Playwright locator APIs
await page.getByRole('button', { name: 'Access Control Panel' }).click();
await page.getByLabel('Host Token').fill(hostToken);
await page.getByPlaceholder('Enter 8-character token').fill(userToken);
```

### **Logging & Security**  
```ts
// SAFE: Log operations without exposing secrets
console.log(`‚úÖ Navigated to host control panel with token ending in ...${hostToken.slice(-4)}`);
console.log(`‚úÖ Button enabled after token validation: ${hostToken.slice(0,4)}****`);
```

### **Error Handling & Resilience**
```ts
// PROVEN: Graceful fallback for database operations
try {
  const hostToken = await dbManager.getHostToken();
  console.log(`‚úÖ Retrieved host token from database: ...${hostToken.slice(-4)}`);
} catch (error) {
  console.log(`‚ö†Ô∏è Database unavailable, using fallback token: VNBPRVII`);
  const hostToken = 'VNBPRVII'; // Permanent Session 212 fallback
}
```

### **CI/CD Stability Rules**
- **NEVER** set `headless: false` (enforced by config)
- **NEVER** override reporters in tests  
- **ALWAYS** design for retry stability (no transient state dependencies)
- **ALWAYS** use configured timeouts (expect.timeout ‚âà 10s)
- Artifacts auto-generated: trace on first retry, screenshots/videos on failure, HTML/JSON reports

Example Skeleton (adapt to TARGETS/NOTES)
/**
 * ${name} ‚Äî auto-generated E2E
 * Targets: ${targets}
 * Notes: ${notes}
 * Generated: ${new Date().toISOString().slice(0,10)}
 */

import { test, expect, type Page } from '@playwright/test';
import { DatabaseTokenManager } from '../utils/database-token-manager';
import { EnhancedTestMonitor } from '../utils/enhanced-test-monitor';

async function fillBlazorInput(page: Page, selector: string, value: string) {
  const input = page.locator(selector);
  await input.clear();
  await input.fill(value);
  await input.dispatchEvent('input');
  await input.dispatchEvent('change');
  await page.waitForTimeout(2000);
}

test.describe('${name}', () => {
  test('navigates and completes the primary flow', async ({ page }) => {
    // Readiness
    await page.goto('/', { waitUntil: 'domcontentloaded' });
    await expect(page).toHaveTitle(/NOOR|Canvas/i);

    // (Optional) DB token acquisition
    let session: any;
    try {
      session = await DatabaseTokenManager.getHostSessionToken();
      console.log('[token] using session id:', session?.id?.slice(-6));
    } catch {
      console.log('[token] DatabaseTokenManager unavailable; proceeding without token');
    }

    // Navigate to first target view (adjust selectors based on TARGETS)
    await page.getByRole('link', { name: /host/i }).click();

    // Example of Blazor-bound field
    if (session?.hostToken) {
      await fillBlazorInput(page, '[data-testid="host-token"]', session.hostToken);
    }

    // Button enablement must be asserted before click
    const continueBtn = page.getByRole('button', { name: /continue/i });
    await expect(continueBtn).toBeEnabled();
    await continueBtn.click();

    // Validate route/content
    await expect(page).toHaveURL(/\/host\/session/i);
    await expect(page.getByRole('heading', { name: /session/i })).toBeVisible();

    // Add more steps derived from ${targets}...
  });
});
```

## **üîç COMPONENT ANALYSIS METHODOLOGY**

When analyzing `${targets}` files, extract these critical elements:

### **From Razor Pages/Components**
- **Routes**: `@page` directives ‚Üí expected navigation sequence
- **Bound Inputs**: `@bind-Value` dependencies ‚Üí requires `fillBlazorInput()` pattern  
- **Conditional Buttons**: `disabled="@(!isValid)"` ‚Üí requires enablement verification
- **Cascading Dropdowns**: API calls populating `<select>` ‚Üí wait for options before selection

### **From Controllers/APIs**
- **Endpoints**: Action methods ‚Üí expected HTTP responses for validation
- **Validation Logic**: Model binding ‚Üí input requirements for successful submission  
- **Error Responses**: Exception handling ‚Üí negative test case scenarios

### **From NOTES Integration**
- **Edge Cases**: Invalid tokens, missing sessions ‚Üí error handling branches
- **Multi-User Scenarios**: Host/User token combinations ‚Üí separate test methods
- **Performance Thresholds**: Expected response times ‚Üí timeout configurations

---

## **üìã FINAL SUCCESS CHECKLIST (All Must Pass)**

Before generating any test, ensure these proven patterns are included:

### **‚úÖ CRITICAL REQUIREMENTS (Non-Negotiable)**
- [ ] **File Location**: `PlayWright/tests/{kebab-case(NAME)}.spec.ts`  
- [ ] **TypeScript**: Uses modern Playwright locator APIs (`getByRole`, `getByLabel`, etc.)
- [ ] **Blazor Binding**: `fillBlazorInput()` used for EVERY form input field
- [ ] **Button Safety**: `expect().toBeEnabled()` verified before EVERY button click
- [ ] **Database Integration**: `DatabaseTokenManager` with Session 212 fallback (VNBPRVII/DPH42JR5)
- [ ] **Application Health**: 30-second timeout with `networkidle` wait for ASP.NET Core startup

### **‚úÖ STABILITY REQUIREMENTS (CI/CD Ready)**  
- [ ] **Headless Compatible**: NO overrides of headless/reporters/trace/video/screenshot settings
- [ ] **Retry Stable**: Works under retry conditions, no transient state dependencies  
- [ ] **Timeout Compliant**: Uses configured timeouts (expect.timeout ‚âà 10s)
- [ ] **Security Safe**: Logs helpful info without exposing secrets (use token slicing)

### **‚úÖ BLAZOR-SPECIFIC PATTERNS (Mandatory)**
- [ ] **Input Events**: `dispatchEvent('input')` and `dispatchEvent('change')` after fill
- [ ] **Binding Wait**: 2000ms `waitForTimeout` after input to allow Blazor processing  
- [ ] **Dropdown Handling**: Wait for cascading dropdowns to populate before selection
- [ ] **URL Validation**: Verify navigation success with `expect().toHaveURL()`

### **‚úÖ ERROR HANDLING (Production Ready)**
- [ ] **Graceful Fallbacks**: Database unavailable ‚Üí use permanent Session 212 tokens
- [ ] **Token Validation**: Verify 8-character format with `/^[A-Z0-9]{8}$/` regex
- [ ] **Enhanced Monitoring**: Optional `EnhancedTestMonitor` for health checks (non-fatal)

---

**Generate the complete, production-ready `.spec.ts` using `${name}`, `${targets}`, and `${notes}` with ALL patterns above included.**