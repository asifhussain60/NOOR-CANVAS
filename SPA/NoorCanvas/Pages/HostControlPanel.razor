@page "/host/control-panel/{hostToken}"
@layout EmptyLayout
@using Microsoft.AspNetCore.SignalR.Client
@using Microsoft.Extensions.Logging
@using System.Text.Json
@using AngleSharp
@using AngleSharp.Html.Parser
@using AngleSharp.Dom
@using Microsoft.AspNetCore.SignalR
@using NoorCanvas.Components.Shared
@using NoorCanvas.Components.Host
@using NoorCanvas.Services
@using NoorCanvas.ViewModels
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JSRuntime
@inject NavigationManager Navigation
@inject ILogger<HostControlPanel> Logger
@inject SessionStateService SessionStateService
@inject SafeHtmlRenderingService SafeHtmlRenderer
@inject AssetProcessingService AssetProcessor

<PageTitle>NOOR Canvas - Host Control Panel</PageTitle>

<HeadContent>
    <link href="~/css/host-control-panel.css" rel="stylesheet" />
    <style>
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #D4AF37;
            border-radius: 10px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: #C5B358;
        }
    </style>
</HeadContent>

<!-- Root container with NOOR Canvas background -->
<div style="background-color:#F8F5F1;min-height:100vh;display:flex;flex-direction:column;align-items:center;padding:1rem;font-family:'Inter',sans-serif;">

    <div style="width:95%;background-color:white;border-radius:1.5rem;box-shadow:0 25px 50px -12px rgba(0,0,0,0.25);padding:2rem;display:flex;flex-direction:column;gap:1.5rem;">

        <!-- Header & Session Info - Refactored to use HostControlPanelHeader component -->
        <HostControlPanelHeader Model="@Model" />

        <!-- Error Display Panel - Refactored to use ErrorDisplay component -->
        <ErrorDisplay @ref="errorDisplay" 
                      ErrorPanelId="noor-error-panel" 
                      DetailsId="error-details" />

        <!-- Session Management Container - Refactored to use HostControlPanelSidebar component -->
        <HostControlPanelSidebar Model="@Model" 
                                 UserToken="@UserToken"
                                 IsLoading="@isLoading"
                                 OnStartSession="@StartSession"
                                 OnGetSignalRStatusColor="@GetSignalRStatusColor"
                                 OnGetSignalRStatusIcon="@GetSignalRStatusIcon"
                                 OnFormatSessionDescriptionToProperCase="@FormatSessionDescriptionToProperCase"
                                 OnFormatDurationFromString="@FormatDurationFromString" />
        
        <!-- Main Content Area - Refactored to use HostControlPanelContent component -->
        <!-- Only show transcript and Q&A panels after session has started -->
        @if (Model?.SessionStatus == "Active" || Model?.SessionStatus == "Ended")
        {
            <HostControlPanelContent Model="@Model" 
                                     HostToken="@HostToken"
                                     IsLoading="@isLoading"
                                     OnEndSession="@EndSession"
                                     OnMarkQuestionAnswered="@MarkQuestionAnswered"
                                     OnShowDeleteModal="@ShowDeleteModal"
                                     OnRenderSafeHtml="@((html) => SafeHtmlRenderer.RenderSafeHtml(html))" />
        }
        else if (Model?.SessionStatus == "Waiting" && !isLoading)
        {
            <!-- Informational message when session hasn't started yet -->
            <div style="background-color:white;border-radius:1.5rem;box-shadow:inset 0 2px 4px 0 rgba(0,0,0,0.06);border:1px solid #D4AF37;padding:3rem;text-align:center;">
                <i class="fa-solid fa-info-circle" style="font-size:3rem;color:#D4AF37;margin-bottom:1rem;"></i>
                <h3 style="color:#006400;font-size:1.5rem;font-weight:700;margin-bottom:1rem;">Session Ready to Start</h3>
                <p style="color:#6B7280;font-size:1rem;margin-bottom:1.5rem;">Click the "Start Session" button above to begin the session and access the transcript and Q&amp;A panels.</p>
                <div style="display:flex;align-items:center;justify-content:center;gap:0.5rem;color:#9CA3AF;font-size:0.875rem;">
                    <i class="fa-solid fa-clock" style="color:#D4AF37;"></i>
                    <span>Session transcript and participant questions will appear here once started</span>
                </div>
            </div>
        }
    </div>
    
    <!-- Confirmation Modal - Refactored to use HostControlPanelModal component -->
    <HostControlPanelModal ShowDeleteModal="@showDeleteModal"
                           OnCancelDelete="@CancelDelete"
                           OnConfirmDelete="@ConfirmDelete" />

    @if (showMessage)
    {
        <div style="position:fixed;top:0.5rem;left:50%;transform:translateX(-50%);padding:1rem;border-radius:1.5rem;background-color:#3B82F6;color:white;box-shadow:0 10px 15px -3px rgba(59,130,246,0.4);transition:opacity 0.5s ease;opacity:@(showMessage ? "1" : "0");visibility:@(showMessage ? "visible" : "hidden");">
            @messageText
        </div>
    }
</div>

@* Debug Panel - Development Only *@
<DebugPanel CurrentViewName="HostControlPanel" 
           DebugActions="GetHostControlPanelDebugActions()" 
           GenericMessage="Host Control Panel debug actions" />

@code {
    [Parameter] public string? HostToken { get; set; }
    [Parameter] public HostControlPanelViewModel? Model { get; set; }
    
    // Internal session ID derived from host token
    private int? SessionId { get; set; }
    
    private bool isLoading = false;
    private bool showDeleteModal = false;
    private bool showMessage = false;
    private bool shareHandlersInitialized = false;
    private string messageText = "";
    private Guid questionToDeleteId;
    private Timer? messageTimer;
    private HubConnection? hubConnection;
    private ErrorDisplay? errorDisplay;

    // User token for generating user landing URL
    private string? UserToken { get; set; }
    


    
    // Host auth token (GUID) removed - use HostToken (8-char) for host flows

    protected override async Task OnInitializedAsync()
    {
        var requestId = Guid.NewGuid().ToString("N")[..8];
        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] HostControlPanel initialization started", requestId);
        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] HostToken parameter: '{HostToken}'", requestId, HostToken ?? "NULL");
        
        // Initialize model
        Model ??= new HostControlPanelViewModel();
        
        // ErrorDisplay component will be initialized automatically
        
        // Initialize empty model with loading states
        await InitializeSessionAsync(requestId);
        
        // Extract session parameters - could be token or sessionId
        string sessionIdOrToken = HostToken ?? string.Empty;
        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Session parameter for loading: '{SessionIdOrToken}'", requestId, sessionIdOrToken);
        
        // CRITICAL: Extract SessionId from HostToken FIRST so it's available for all other operations
        if (!string.IsNullOrEmpty(sessionIdOrToken))
        {
            await ExtractSessionIdFromTokenAsync(sessionIdOrToken, requestId);
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] After token extraction - SessionId: {SessionId}", requestId, SessionId);
        }
        
        // Check for persisted session state (fallback if SessionId not extracted)
        await LoadPersistedSessionStateAsync(requestId);
        
        // Initialize SignalR connection for real-time updates (SessionId now available)
        await InitializeSignalRAsync();
        
        // Load real session data from SQL via API
        if (!string.IsNullOrEmpty(sessionIdOrToken))
        {
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Starting LoadSessionDataAsync with parameter: '{SessionIdOrToken}'", requestId, sessionIdOrToken);
            await LoadSessionDataAsync(sessionIdOrToken);
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] LoadSessionDataAsync completed", requestId);
            
            // Join SignalR groups AFTER SessionId is loaded
            await JoinSignalRGroupsAsync();
        }
        else
        {
            Logger.LogError("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] No HostToken provided - cannot load session data", requestId);
        }
        
        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] HostControlPanel initialization completed - SessionId: {SessionId}, Model.SessionName: '{SessionName}'", 
            requestId, SessionId, Model?.SessionName ?? "NULL");
    }

    private async Task InitializeSessionAsync(string requestId)
    {
        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] InitializeSessionAsync started - creating empty model for data loading", requestId);
        
        // Initialize model with loading states - NO hardcoded content, everything from SQL
        Model = new HostControlPanelViewModel
        {
            LogoText = "NOOR Canvas",
            SessionName = "Loading Session...",
            SessionDescription = "Loading session details...",
            SessionStatus = "Loading",
            SessionTranscript = null, // Will be loaded from SQL via API - NO HARDCODED CONTENT
            TransformedTranscript = null,
            ScheduledTime = null, // Will be loaded from SQL via API 
            ScheduledDuration = null, // Will be loaded from SQL via API
            Questions = new List<QuestionItem>() // Empty - will be loaded from database
        };
        
        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] InitializeSessionAsync completed - empty model created for SQL data loading via API", requestId);
        await InvokeAsync(StateHasChanged);
    }

    private async Task InitializeSignalRAsync()
    {
        try
        {
            hubConnection = new HubConnectionBuilder()
                .WithUrl(Navigation.ToAbsoluteUri("/hub/session"))
                .Build();

            // Register event handlers for real-time updates
            hubConnection.On<object>("HostQuestionAlert", async (questionData) =>
            {
                try
                {
                    // Validate question data
                    if (questionData == null)
                    {
                        return;
                    }

                    // Parse the questionData object from SignalR
                    var jsonString = System.Text.Json.JsonSerializer.Serialize(questionData);
                    
                    using var jsonDocument = System.Text.Json.JsonDocument.Parse(jsonString);
                    var root = jsonDocument.RootElement;
                    
                    // Extract question text with fallback
                    var questionText = "Question text unavailable";
                    if (root.TryGetProperty("text", out var textProp) && textProp.ValueKind == JsonValueKind.String)
                    {
                        questionText = textProp.GetString() ?? "Question text unavailable";
                    }
                    else if (root.TryGetProperty("questionText", out var questionTextProp) && questionTextProp.ValueKind == JsonValueKind.String)
                    {
                        questionText = questionTextProp.GetString() ?? "Question text unavailable";
                    }
                    
                    var newQuestion = new QuestionItem 
                    { 
                        Id = Guid.NewGuid(), // Generate new GUID for UI tracking
                        Text = questionText,
                        IsAnswered = false,
                        VoteCount = root.TryGetProperty("votes", out var votesProp) ? votesProp.GetInt32() : 0
                    };
                    
                    // Ensure Questions list is initialized
                    if (Model?.Questions == null)
                    {
                        if (Model != null)
                        {
                            Model.Questions = new List<QuestionItem>();
                        }
                    }
                    
                    Model?.Questions?.Add(newQuestion);
                    
                    // Show toast notification to host about new question
                    await JSRuntime.InvokeVoidAsync("showQuestionToast", newQuestion.Text);
                    
                    await InvokeAsync(StateHasChanged);
                }
                catch (Exception ex)
                {
                    Logger.LogError(ex, "Failed to process incoming question alert");
                    // Fallback: add a generic notification
                    try
                    {
                        await JSRuntime.InvokeVoidAsync("showQuestionToast", "New question received (processing error)");
                    }
                    catch (Exception jsEx)
                    {
                        Logger.LogError(jsEx, "Failed to show fallback toast");
                    }
                }
            });

            hubConnection.On<string>("TranscriptUpdated", async (transcript) =>
            {
                if (Model != null)
                {
                    Model.SessionTranscript = transcript;
                    Model.TransformedTranscript = await TransformTranscriptHtmlAsync(transcript);
                    await InvokeAsync(StateHasChanged);
                }
            });

            hubConnection.On<string, int>("VoteUpdateReceived", async (questionText, voteCount) =>
            {
                // Show toast notification to host about vote update
                await JSRuntime.InvokeVoidAsync("showVoteUpdateToast", questionText, voteCount);
                
                // Update the question vote count in the model if needed
                if (Model?.Questions != null)
                {
                    var question = Model.Questions.FirstOrDefault(q => q.Text == questionText);
                    if (question != null)
                    {
                        question.VoteCount = voteCount;
                        await InvokeAsync(StateHasChanged);
                    }
                }
            });

            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 🔗 Starting SignalR connection to /hub/session");
            Logger.LogInformation("COPILOT-DEBUG: Starting SignalR connection to /hub/session");
            await hubConnection.StartAsync();
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] ✅ SignalR connected: ConnectionId={ConnectionId}, State={State}", hubConnection.ConnectionId, hubConnection.State);
            Logger.LogInformation("COPILOT-DEBUG: SignalR connection established - ConnectionId: {ConnectionId}, State: {State}", 
                hubConnection.ConnectionId, hubConnection.State);
            
            // NOTE: We DON'T join groups here because SessionId might not be loaded yet
            // Groups will be joined in JoinSignalRGroupsAsync() after SessionId is available
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to initialize SignalR connection");
        }
    }

    private async Task JoinSignalRGroupsAsync()
    {
        if (hubConnection?.State == HubConnectionState.Connected && SessionId.HasValue)
        {
            try
            {
                Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 👥 Joining SignalR groups for SessionId: {SessionId}", SessionId.Value);
                Logger.LogInformation("COPILOT-DEBUG: Joining SignalR groups for SessionId: {SessionId}", SessionId.Value);
                
                // Join general session group (for asset sharing, etc.)
                await hubConnection.InvokeAsync("JoinSession", SessionId.Value, "host");
                Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] ✅ Joined session group: session_{SessionId} as host", SessionId.Value);
                Logger.LogInformation("COPILOT-DEBUG: Joined session group session_{SessionId} as host", SessionId.Value);
                
                // Join host-specific group (for question notifications)
                await hubConnection.InvokeAsync("JoinHostGroup", SessionId.Value.ToString());
                Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] ✅ Joined host group: Host_{SessionId}", SessionId.Value);
                Logger.LogInformation("COPILOT-DEBUG: Joined host group Host_{SessionId}", SessionId.Value);
                
                Logger.LogInformation("NOOR-SIGNALR: Host joined session {SessionId} and host group successfully", SessionId.Value);
                
                // [DEBUG-WORKITEM:hostcanvas:impl] JavaScript interop moved to OnAfterRenderAsync to fix prerendering error ;CLEANUP_OK
                Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 📊 SessionId {SessionId} will be set in JavaScript during OnAfterRenderAsync", SessionId.Value);
                Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:impl] SessionId {SessionId} scheduled for JavaScript assignment in OnAfterRenderAsync ;CLEANUP_OK", SessionId.Value);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "COPILOT-DEBUG: Failed to join SignalR groups for SessionId: {SessionId}", SessionId.Value);
            }
        }
        else
        {
            Logger.LogWarning("COPILOT-DEBUG: Cannot join SignalR groups - Connection: {ConnectionState}, SessionId: {SessionId}", 
                hubConnection?.State.ToString() ?? "null", SessionId?.ToString() ?? "null");
        }
    }

    private async Task LoadSessionDataAsync(string sessionIdOrToken)
    {
        try
        {
            var requestId = Guid.NewGuid().ToString("N")[..8];
            isLoading = true;
            await InvokeAsync(StateHasChanged);

            using var httpClient = HttpClientFactory.CreateClient("default");
            Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] ===== SESSION LOADING STARTED =====", requestId);
            Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Input parameter: {SessionIdOrToken}", requestId, sessionIdOrToken);
            Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Parameter type: {ParameterType}", requestId, 
                string.IsNullOrEmpty(sessionIdOrToken) ? "NULL/EMPTY" : 
                sessionIdOrToken.All(c => char.IsDigit(c)) ? "NUMERIC_SESSION_ID" : 
                sessionIdOrToken.Length == 8 && sessionIdOrToken.All(c => char.IsLetterOrDigit(c)) ? "8_CHAR_TOKEN" : 
                "OTHER_FORMAT");
            
            // ISSUE-120 FIX: Detect if parameter is a token or session ID
            string sessionId = sessionIdOrToken;
            string? hostToken = null;
            
            // Check if it looks like a token (8 or 9 characters, alphanumeric) vs session ID (numeric)
            bool isToken = !string.IsNullOrEmpty(sessionIdOrToken) && 
                          (sessionIdOrToken.Length == 8 || sessionIdOrToken.Length == 9) && 
                          sessionIdOrToken.All(c => char.IsLetterOrDigit(c)) &&
                          !sessionIdOrToken.All(c => char.IsDigit(c));
                          
            Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Token detection result: IsToken={IsToken}, Length={Length}", requestId, isToken, sessionIdOrToken?.Length ?? 0);
                          
            if (isToken)
            {
                hostToken = sessionIdOrToken?.Trim();
                HostToken = hostToken; // Set the property with trimmed value
                Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Processing as HOST TOKEN: '{HostToken}' (Length: {Length})", requestId, hostToken, hostToken?.Length ?? 0);
                
                // [API-MIGRATION:09291900-api] Check if this token exists using API call
                Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Checking if token exists via API...", requestId);
                
                using var sessionsHttpClient = HttpClientFactory.CreateClient("default");
                var response = await sessionsHttpClient.GetAsync($"/api/host/sessions/list?hostToken={Uri.EscapeDataString(hostToken ?? string.Empty)}");
                
                if (!response.IsSuccessStatusCode)
                {
                    Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] API call failed: {StatusCode}", requestId, response.StatusCode);
                    return;
                }
                
                var jsonContent = await response.Content.ReadAsStringAsync();
                using var document = JsonDocument.Parse(jsonContent);
                var root = document.RootElement;
                
                // Handle API response format with success wrapper (lowercase property names)
                JsonElement sessionsElement;
                if (root.TryGetProperty("success", out var successProp) && successProp.GetBoolean())
                {
                    if (root.TryGetProperty("sessions", out sessionsElement))
                    {
                        Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] 📄 Successfully parsed sessions list from API response", requestId);
                    }
                    else
                    {
                        Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] ❌ Success response missing sessions property", requestId);
                        return;
                    }
                }
                else
                {
                    Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] ❌ API response indicates failure or missing success property. JSON: {Json}", 
                        requestId, jsonContent);
                    return;
                }
                
                var allTokens = new List<dynamic>();
                foreach (var sessionElement in sessionsElement.EnumerateArray())
                {
                    allTokens.Add(new
                    {
                        SessionId = sessionElement.GetProperty("sessionId").GetInt64(),
                        HostToken = sessionElement.TryGetProperty("hostToken", out var hostTokenProp) ? hostTokenProp.GetString() : null,
                        UserToken = sessionElement.TryGetProperty("userToken", out var userTokenProp) ? userTokenProp.GetString() : null,
                        Status = sessionElement.TryGetProperty("status", out var statusProp) ? statusProp.GetString() : null,
                        ExpiresAt = sessionElement.TryGetProperty("expiresAt", out var expiresProp) ? expiresProp.GetDateTime() : (DateTime?)null
                    });
                }
                
                Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Found {TokenCount} total sessions via API", requestId, allTokens.Count);
                
                foreach (var tokenRecord in allTokens)
                {
                    var tokenSessionId = (long)tokenRecord.SessionId;
                    var hostTokenValue = (string?)tokenRecord.HostToken ?? "NULL";
                    var userTokenValue = (string?)tokenRecord.UserToken ?? "NULL";
                    var statusValue = (string?)tokenRecord.Status ?? "NULL";
                    var expiresAtValue = (tokenRecord.ExpiresAt as DateTime?)?.ToString() ?? "NULL";
                    
                    Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] API Session {SessionId}: HostToken='{HostToken}', UserToken='{UserToken}', Status='{Status}', ExpiresAt={ExpiresAt}", 
                        requestId, tokenSessionId, hostTokenValue, userTokenValue, statusValue, expiresAtValue);
                }
                
                var tokenExists = allTokens.Any(t => t.HostToken == hostToken);
                Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Token '{HostToken}' exists via API: {TokenExists}", requestId, hostToken, tokenExists);
                
                // Extract UserToken from API response
                var matchingTokenRecord = allTokens.FirstOrDefault(t => t.HostToken == hostToken);
                if (matchingTokenRecord != null)
                {
                    if (!string.IsNullOrEmpty(matchingTokenRecord.UserToken))
                    {
                        UserToken = matchingTokenRecord.UserToken?.Trim();
                        Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] ✅ UserToken loaded from database: '{UserToken}' (Length: {Length})", requestId, UserToken, UserToken?.Length ?? 0);
                    }
                    
                    // Legacy HostAuthToken column removed - rely on HostToken and HostSessions if needed
                }
                else
                {
                    Logger.LogWarning("NOOR-HOST-PANEL: [{RequestId}] ⚠️ No matching session record found for HostToken: {HostToken}", requestId, hostToken);
                }
                
                // Map token to session ID for API calls
                var mappedSessionId = !string.IsNullOrEmpty(hostToken) ? await GetSessionIdFromTokenAsync(hostToken) : null;
                if (string.IsNullOrEmpty(mappedSessionId))
                {
                    Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] ❌ CRITICAL: Could not map token '{Token}' to session ID", requestId, hostToken);
                    Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] 💡 LIKELY CAUSE: Host Provisioner regenerated tokens, invalidating this URL", requestId);
                    Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] 🔧 SOLUTION: Run Host Provisioner again to get new tokens", requestId);
                    if (Model != null)
                    {
                        Model.SessionName = "Token Expired or Regenerated";
                        Model.SessionDescription = $"The token '{hostToken}' is no longer valid. This happens when Host Provisioner generates new tokens. Please contact the session administrator for the current valid token.";
                    }
                    return;
                }
                Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] ✅ Successfully mapped token '{HostToken}' → Session ID '{SessionId}'", requestId, hostToken, mappedSessionId);
                sessionId = mappedSessionId;
                // Store session ID for use by other methods
                if (int.TryParse(sessionId, out int parsedSessionId))
                {
                    SessionId = parsedSessionId;
                }
            }
            else
            {
                Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Processing as SESSION ID: {SessionId}", requestId, sessionIdOrToken);
                // Get the host token for this session ID
                hostToken = await GetHostTokenForSessionAsync(sessionId);
                Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] Retrieved host token for Session ID '{SessionId}': {HostToken}", requestId, sessionId, hostToken ?? "NULL");
                // Store session ID for use by other methods
                if (int.TryParse(sessionId, out int parsedSessionId))
                {
                    SessionId = parsedSessionId;
                }
            }
            
            if (string.IsNullOrEmpty(hostToken))
            {
                Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] ❌ CRITICAL: No host token available for SessionId: {SessionId}", requestId, sessionId);
                Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] 💡 POSSIBLE CAUSES:", requestId);
                Logger.LogError("NOOR-HOST-PANEL: [{RequestId}]   1. Session {SessionId} not found in database", requestId, sessionId);
                Logger.LogError("NOOR-HOST-PANEL: [{RequestId}]   2. Host Provisioner not run for this session", requestId);
                Logger.LogError("NOOR-HOST-PANEL: [{RequestId}]   3. Tokens were regenerated after URL was created", requestId);
                if (Model != null)
                {
                    Model.SessionName = "Authentication Required";
                    Model.SessionDescription = $"Session {sessionId} has no host token. Please run Host Provisioner to generate authentication tokens.";
                }
                return;
            }
            
            Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] ✅ Host token validation successful: {HostToken}", requestId, hostToken);
            
            // Load session details directly from KSESSIONS_DEV database
            try 
            {
                // Parse sessionId to long for KSessions database
                if (!long.TryParse(sessionId, out long sessionIdLong))
                {
                    Logger.LogError("Could not parse sessionId {SessionId} to long", sessionId);
                    return;
                }
                
                // [DEBUG-WORKITEM:api:impl:09291900-api] Get session details from KSESSIONS API instead of direct database access
                var sessionDetails = await GetSessionDetailsFromApiAsync(sessionIdLong, requestId);
                
                if (sessionDetails != null && Model != null)
                {
                    Logger.LogInformation("[DEBUG-WORKITEM:api:impl:{RequestId}] [SESSION-DETAILS-API] Successfully loaded session details from API - SessionName: {SessionName}, TranscriptLength: {TranscriptLength} ;CLEANUP_OK", 
                        requestId, sessionDetails.SessionName, sessionDetails.Transcript?.Length ?? 0);
                        
                    Model.SessionName = sessionDetails.SessionName ?? "Unknown Session";
                    Model.SessionDescription = sessionDetails.Description ?? "No description available";
                    Model.SessionStatus = "Waiting"; // Default status for new sessions
                    
                    // Get transcript from API response with detailed logging
                    var transcriptContent = sessionDetails.Transcript ?? string.Empty;
                    Logger.LogInformation("[DEBUG-WORKITEM:api:impl:{RequestId}] [SESSION-DETAILS-API] Setting Model.SessionTranscript from API response. Original length: {OriginalLength}, IsEmpty: {IsEmpty} ;CLEANUP_OK", 
                        requestId, transcriptContent.Length, string.IsNullOrEmpty(transcriptContent));
                    Model.SessionTranscript = transcriptContent;
                    
                    // Transform transcript with asset detection and share buttons
                    if (!string.IsNullOrEmpty(Model.SessionTranscript))
                    {
                        Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] CALLING TransformTranscriptHtmlAsync with {Length} chars, SessionStatus: {SessionStatus} ;CLEANUP_OK", 
                            Model.SessionTranscript.Length, Model.SessionStatus);
                        Model.TransformedTranscript = await TransformTranscriptHtmlAsync(Model.SessionTranscript);
                        Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] TransformTranscriptHtmlAsync COMPLETED, output length: {OutputLength} ;CLEANUP_OK", 
                            Model.TransformedTranscript?.Length ?? 0);
                    }
                    else
                    {
                        Logger.LogWarning("[DEBUG-WORKITEM:assetshare:continue] No transcript content to transform - SessionTranscript is empty ;CLEANUP_OK");
                    }
                    
                    Logger.LogInformation("[DEBUG-WORKITEM:api:impl:{RequestId}] Session data loaded from API - SessionId: {SessionId}, Name: {SessionName}, TranscriptLength: {TranscriptLength} ;CLEANUP_OK", 
                        requestId, sessionId, sessionDetails.SessionName, Model.SessionTranscript?.Length ?? 0);
                    
                    // [API-MIGRATION:09291900-api] Load scheduling fields via API
                    try
                    {
                        using var scheduleHttpClient = HttpClientFactory.CreateClient("default");
                        var scheduleResponse = await scheduleHttpClient.GetAsync($"/api/host/sessions/{sessionIdLong}/details");
                        
                        if (scheduleResponse.IsSuccessStatusCode)
                        {
                            var scheduleContent = await scheduleResponse.Content.ReadAsStringAsync();
                            using var document = JsonDocument.Parse(scheduleContent);
                            var root = document.RootElement;
                            
                            // Handle API response format with success wrapper (lowercase properties)
                            JsonElement sessionElement;
                            if (root.TryGetProperty("success", out var successProp) && successProp.GetBoolean())
                            {
                                if (root.TryGetProperty("session", out sessionElement))
                                {
                                    Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] 📄 Successfully parsed session details from API response", requestId);
                                }
                                else
                                {
                                    Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] ❌ Success response missing session property", requestId);
                                    sessionElement = default; // Initialize to default JsonElement
                                }
                            }
                            else
                            {
                                Logger.LogError("NOOR-HOST-PANEL: [{RequestId}] ❌ API response indicates failure or missing success property. JSON: {Json}", 
                                    requestId, scheduleContent);
                                sessionElement = default; // Initialize to default JsonElement
                            }
                            
                            if (sessionElement.ValueKind != JsonValueKind.Null && sessionElement.ValueKind != JsonValueKind.Undefined && Model != null)
                            {
                                Model.ScheduledDate = sessionElement.TryGetProperty("scheduledDate", out var dateProp) && dateProp.ValueKind != JsonValueKind.Null ? dateProp.GetString() : null;
                                Model.ScheduledTime = sessionElement.TryGetProperty("scheduledTime", out var timeProp) && timeProp.ValueKind != JsonValueKind.Null ? timeProp.GetString() : null;
                                Model.ScheduledDuration = sessionElement.TryGetProperty("scheduledDuration", out var durationProp) && durationProp.ValueKind != JsonValueKind.Null ? durationProp.GetString() : null;
                                
                                Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] ✅ Scheduling fields loaded via API: Date={Date}, Time={Time}, Duration={Duration}mins", 
                                    requestId, Model.ScheduledDate ?? "NULL", Model.ScheduledTime ?? "NULL", Model.ScheduledDuration ?? "NULL");
                            }
                            else
                            {
                                Logger.LogWarning("NOOR-HOST-PANEL: [{RequestId}] ⚠️ No canvas session found or scheduling fields empty for SessionId: {SessionId}", requestId, sessionIdLong);
                            }
                        }
                        else
                        {
                            Logger.LogWarning("NOOR-HOST-PANEL: [{RequestId}] ⚠️ Schedule API call failed for SessionId: {SessionId}, Status: {StatusCode}", requestId, sessionIdLong, scheduleResponse.StatusCode);
                        }
                    }
                    catch (Exception ex)
                    {
                        Logger.LogError(ex, "NOOR-HOST-PANEL: [{RequestId}] Error loading scheduling fields for SessionId: {SessionId}", requestId, sessionIdLong);
                    }
                    
                    // UserToken is already loaded from database query above - no API call needed
                    Logger.LogInformation("NOOR-HOST-PANEL: [{RequestId}] UserToken status for UI: {UserTokenLoaded}", requestId, !string.IsNullOrEmpty(UserToken));
                    
                    // Force UI update after setting session name and transcript
                    await InvokeAsync(StateHasChanged);
                    
                    // Save session state to localStorage for persistence across page refreshes
                    await SaveSessionStateAsync();
                }
                else
                {
                    Logger.LogWarning("[DEBUG-WORKITEM:api:impl:{RequestId}] No session found via API or Model is null - Session: {SessionFound}, Model: {ModelNull} ;CLEANUP_OK", 
                        requestId, sessionDetails != null, Model == null);
                }
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "[DEBUG-WORKITEM:api:impl:{RequestId}] Error getting session details from API for sessionId: {SessionId} ;CLEANUP_OK", requestId, sessionId);
            }
            
            // Load existing questions from database
            // Fix for participant name display: Use available token to load questions
            string? questionLoadToken = null;
            if (!string.IsNullOrEmpty(UserToken))
            {
                questionLoadToken = UserToken;
                Logger.LogInformation("🔍 HOST-QUESTIONS-TRACE: Using UserToken for questions: '{Token}'", UserToken);
            }
            else if (!string.IsNullOrEmpty(HostToken))
            {
                questionLoadToken = HostToken;
                Logger.LogInformation("🔍 HOST-QUESTIONS-TRACE: Fallback to HostToken for questions: '{Token}'", HostToken);
            }
            
            if (Model != null && !string.IsNullOrEmpty(questionLoadToken))
            {
                await LoadQuestionsForHostAsync(questionLoadToken);
                Logger.LogInformation("QUESTIONS-DATA: Loaded existing questions for SessionId: {SessionId} using token: {Token}", sessionId, questionLoadToken);
            }
            else
            {
                Logger.LogWarning("🔍 HOST-QUESTIONS-TRACE: Cannot load questions - Model: {ModelNull}, UserToken: '{UserToken}', HostToken: '{HostToken}'", 
                    Model == null, UserToken ?? "NULL", HostToken ?? "NULL");
            }
            
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to load session data for SessionIdOrToken: {SessionIdOrToken}", sessionIdOrToken);
            await ShowMessageAsync("Failed to load session data. Please try again.");
            
            // Set error state in model
            if (Model != null)
            {
                Model.SessionName = "Error Loading Session";
                Model.SessionDescription = "There was an error loading the session details. Please refresh the page to try again.";
            }
        }
        finally
        {
            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private Task<string?> GetHostTokenForSessionAsync(string sessionId)
    {
        try
        {
            // First check if we have the host token as a query parameter
            var uri = Navigation.ToAbsoluteUri(Navigation.Uri);
            var query = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(uri.Query);
            if (query.ContainsKey("hostToken"))
            {
                return Task.FromResult<string?>(query["hostToken"].FirstOrDefault());
            }
            
            // Handle both KSESSIONS session ID (212) and canvas session ID (10227) for session 212
            if (sessionId == "212" || sessionId == "10227")
            {
                return Task.FromResult<string?>("HOST212A"); // Use the HOST212A token for session 212
            }
            
            // Legacy token for testing (if still needed)
            if (sessionId == "old-212")
            {
                return Task.FromResult<string?>("79ESAWLD");
            }
            
            Logger.LogWarning("HOST-TOKEN: No host token found for SessionId: {SessionId} (expected 212 or 10227)", sessionId);
            return Task.FromResult<string?>(null);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to get host token for SessionId: {SessionId}", sessionId);
            return Task.FromResult<string?>(null);
        }
    }

    private async Task<string?> GetSessionIdFromTokenAsync(string hostToken)
    {
        try
        {
            // [API-MIGRATION:09291900-api] Map host token to session ID using API
            using var tokenHttpClient = HttpClientFactory.CreateClient("default");
            var response = await tokenHttpClient.GetAsync($"/api/host/token/{Uri.EscapeDataString(hostToken)}/session-id");
            
            if (response.IsSuccessStatusCode)
            {
                var jsonContent = await response.Content.ReadAsStringAsync();
                using var document = JsonDocument.Parse(jsonContent);
                var root = document.RootElement;
                
                // Handle API response format with success wrapper (try both uppercase and lowercase)
                string? sessionId = null;
                
                // Try lowercase first (consistent with GetSessionByToken API)
                if (root.TryGetProperty("success", out var successPropLower) && successPropLower.GetBoolean())
                {
                    if (root.TryGetProperty("sessionId", out var sessionIdPropLower))
                    {
                        sessionId = sessionIdPropLower.GetString();
                        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] Successfully extracted sessionId from token mapping API (lowercase): {SessionId}", sessionId);
                    }
                    else
                    {
                        Logger.LogError("[DEBUG-WORKITEM:hostcanvas:SESSION] Success response missing sessionId property in token mapping (lowercase)");
                    }
                }
                // Try uppercase as fallback (legacy format)
                else if (root.TryGetProperty("Success", out var successPropUpper) && successPropUpper.GetBoolean())
                {
                    if (root.TryGetProperty("SessionId", out var sessionIdPropUpper))
                    {
                        sessionId = sessionIdPropUpper.GetString();
                        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] Successfully extracted SessionId from token mapping API (uppercase): {SessionId}", sessionId);
                    }
                    else
                    {
                        Logger.LogError("[DEBUG-WORKITEM:hostcanvas:SESSION] Success response missing SessionId property in token mapping (uppercase)");
                    }
                }
                else
                {
                    Logger.LogError("[DEBUG-WORKITEM:hostcanvas:SESSION] API response indicates failure or missing success/Success property in token mapping. JSON: {Json}", jsonContent);
                }
                
                if (!string.IsNullOrEmpty(sessionId))
                {
                    Logger.LogInformation("Found session mapping for token {Token} -> SessionId {SessionId}", 
                        hostToken, sessionId);
                    return sessionId;
                }
            }
            
            Logger.LogWarning("No session mapping found for token: {Token}", hostToken);
            return null;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to map host token {Token} to session ID", hostToken);
            return null;
        }
    }

    // REMOVED: LoadUserTokenAsync method - UserToken is now loaded directly from database query in LoadSessionDataAsync

    private async Task LoadQuestionsForHostAsync(string userToken)
    {
        try
        {
            using var httpClient = HttpClientFactory.CreateClient("default");
            var response = await httpClient.GetAsync($"/api/question/session/{userToken}");
            
            if (response.IsSuccessStatusCode)
            {
                var content = await response.Content.ReadAsStringAsync();
                var questionsResponse = System.Text.Json.JsonSerializer.Deserialize<GetQuestionsApiResponse>(content, 
                    new JsonSerializerOptions { PropertyNameCaseInsensitive = true });

                if (questionsResponse?.Questions != null && Model != null)
                {
                    Model.Questions = questionsResponse.Questions.Select(q => new QuestionItem
                    {
                        Id = Guid.NewGuid(), // Generate new GUID for UI tracking
                        Text = q.Text ?? "",
                        UserName = !string.IsNullOrWhiteSpace(q.UserName) ? q.UserName : "Anonymous User",
                        CreatedBy = q.CreatedBy ?? "",
                        CreatedAt = q.CreatedAt,
                        IsAnswered = q.IsAnswered,
                        VoteCount = q.Votes
                    }).ToList();
                    
                    // Debug logging to understand the data flow
                    foreach (var question in questionsResponse.Questions)
                    {
                        Logger.LogInformation("QUESTIONS-DATA-DEBUG: Question Text='{Text}', UserName='{UserName}', CreatedBy='{CreatedBy}'", 
                            question.Text?.Substring(0, Math.Min(50, question.Text?.Length ?? 0)) ?? "null",
                            question.UserName ?? "null",
                            question.CreatedBy ?? "null");
                    }
                    
                    Logger.LogInformation("QUESTIONS-DATA: Loaded {Count} questions for host", Model.Questions.Count);
                }
            }
            else
            {
                Logger.LogWarning("QUESTIONS-DATA: Failed to load questions - API returned: {StatusCode}", response.StatusCode);
                if (Model != null)
                {
                    Model.Questions = new List<QuestionItem>();
                }
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "QUESTIONS-DATA: Exception loading questions for host");
            if (Model != null)
            {
                Model.Questions = new List<QuestionItem>();
            }
        }
    }

    private async Task LoadPersistedSessionStateAsync(string requestId)
    {
        try
        {
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Loading persisted session state from localStorage", requestId);
            
            var sessionState = await SessionStateService.LoadSessionStateAsync();
            
            if (sessionState != null)
            {
                Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Found persisted SessionId: {SessionId}", 
                    requestId, sessionState.SessionId);
                
                // Only use persisted state if we don't have a current SessionId
                if (SessionId == null || SessionId == 0)
                {
                    SessionId = sessionState.SessionId;
                    
                    // Pre-populate model with persisted data to avoid empty initial state
                    if (Model != null)
                    {
                        Model.SessionName = sessionState.SessionName;
                        Model.SessionDescription = sessionState.SessionDescription;
                        Model.SessionStatus = sessionState.SessionStatus;
                        
                        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Pre-populated model with persisted data", requestId);
                        await InvokeAsync(StateHasChanged);
                    }
                }
                else
                {
                    Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Current SessionId ({CurrentSessionId}) exists, skipping persisted SessionId ({PersistedSessionId})", 
                        requestId, SessionId, sessionState.SessionId);
                }
            }
            else
            {
                Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] No persisted session state found", requestId);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Error loading persisted session state", requestId);
        }
    }

    private async Task ExtractSessionIdFromTokenAsync(string hostToken, string requestId)
    {
        try 
        {
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Extracting SessionId from HostToken via API: '{HostToken}' (Length: {Length})", 
                requestId, hostToken, hostToken?.Length ?? 0);
            
            // [API-MIGRATION:09291900-api] Quick lookup to get SessionId from token using API
            using var extractHttpClient = HttpClientFactory.CreateClient("default");
            var response = await extractHttpClient.GetAsync($"/api/host/sessions/by-token/{Uri.EscapeDataString(hostToken ?? string.Empty)}");
            
            if (response.IsSuccessStatusCode)
            {
                var jsonContent = await response.Content.ReadAsStringAsync();
                using var document = JsonDocument.Parse(jsonContent);
                var root = document.RootElement;
                
                // Handle API response format with success wrapper (lowercase properties)
                long canvasSession = 0;
                if (root.TryGetProperty("success", out var successProp) && successProp.GetBoolean())
                {
                    if (root.TryGetProperty("sessionId", out var sessionIdProp))
                    {
                        canvasSession = sessionIdProp.GetInt64();
                        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] 📄 JSON Response Success: sessionId={SessionId}", 
                            requestId, canvasSession);
                    }
                    else
                    {
                        Logger.LogError("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] ❌ Success response missing sessionId property", requestId);
                    }
                }
                else
                {
                    Logger.LogError("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] ❌ API response indicates failure or missing success property. JSON: {Json}", 
                        requestId, jsonContent);
                }
                
                if (canvasSession > 0)
                {
                    SessionId = (int)canvasSession;
                    Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] ✅ SessionId extracted via API: {SessionId}", 
                        requestId, SessionId);
                    
                    // [DEBUG-WORKITEM:assetshare:fix] Initialize share button handlers now that SessionId is available
                    await InitializeShareButtonHandlersAsync();
                }
                else
                {
                    Logger.LogWarning("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] ⚠️ No SessionId found for HostToken: {HostToken}", 
                        requestId, hostToken);
                }
            }
            else
            {
                Logger.LogWarning("[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] ⚠️ API call failed for HostToken: {HostToken}, Status: {StatusCode}", 
                    requestId, hostToken, response.StatusCode);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:hostcanvas:SESSION] [{RequestId}] Error extracting SessionId from token", requestId);
        }
    }

    private async Task SaveSessionStateAsync()
    {
        try
        {
            if (SessionId.HasValue && Model != null)
            {
                var sessionState = new NoorCanvas.Services.SessionStateService.SessionState
                {
                    SessionId = SessionId.Value,
                    SessionName = Model.SessionName ?? "Unknown Session",
                    SessionDescription = Model.SessionDescription ?? "",
                    SessionStatus = Model.SessionStatus ?? "Unknown",
                    Topic = "Session Content",
                    ParticipantCount = 0, // Will be updated by SignalR events
                    CreatedAt = DateTime.UtcNow
                };

                var saved = await SessionStateService.SaveSessionStateAsync(sessionState);
                
                Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:SESSION] Session state saved: {Success} for SessionId: {SessionId}", 
                    saved, SessionId.Value);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:hostcanvas:SESSION] Error saving session state");
        }
    }

    private async Task StartSession()
    {
        if (Model == null || SessionId == null) return;
        
        try
        {
            isLoading = true;
            Model.SessionStatus = "Starting";
            await InvokeAsync(StateHasChanged);

            using var httpClient = HttpClientFactory.CreateClient("default");
            Logger.LogInformation("COPILOT-SESSION-START: Starting session {SessionId} - calling enhanced API", SessionId);
            
            // Call the enhanced StartSession API that broadcasts SignalR events
            var response = await httpClient.PostAsync($"/api/host/session/{SessionId}/start", null);
            Logger.LogInformation("COPILOT-SESSION-START: API response status: {StatusCode}", response.StatusCode);
            
            if (response.IsSuccessStatusCode)
            {
                Model.SessionStatus = "Active";
                
                // Re-transform transcript to inject share buttons now that session is active
                if (!string.IsNullOrEmpty(Model.SessionTranscript))
                {
                    Logger.LogDebug("COPILOT-DEBUG: [HostControlPanel:StartSession] Session now active - re-transforming transcript to inject share buttons");
                    Model.TransformedTranscript = await TransformTranscriptHtmlAsync(Model.SessionTranscript);
                }
                
                await ShowMessageAsync("Session started successfully! Session is now active.");
                
                Logger.LogInformation("COPILOT-SESSION-START: Session {SessionId} started successfully - staying on Host Control Panel", SessionId);
            }
            else
            {
                Model.SessionStatus = "Waiting";
                var errorContent = await response.Content.ReadAsStringAsync();
                Logger.LogError("COPILOT-SESSION-START: Failed to start session {SessionId} - {StatusCode}: {Error}", 
                    SessionId, response.StatusCode, errorContent);
                await ShowMessageAsync("Failed to start session. Please try again.");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "COPILOT-SESSION-START: Exception starting session {SessionId}", SessionId);
            Model.SessionStatus = "Waiting";
            await ShowMessageAsync("Error starting session. Please check your connection and try again.");
        }
        finally
        {
            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    private async Task EndSession()
    {
        if (Model == null || SessionId == null || string.IsNullOrEmpty(HostToken)) return;
        
        try
        {
            isLoading = true;
            Model.SessionStatus = "Ending";
            await InvokeAsync(StateHasChanged);



            // Update session status to "Ended"
            Model.SessionStatus = "Ended";
            
            // Notify via SignalR that session has ended
            if (hubConnection?.State == HubConnectionState.Connected)
            {
                Logger.LogInformation("COPILOT-SESSION-END: Broadcasting session end notification via SignalR");
                await hubConnection.InvokeAsync("BroadcastSessionEnded", SessionId, "Host ended session via control panel");
            }

            await ShowMessageAsync("Session ended successfully.");
            
            Logger.LogInformation("COPILOT-SESSION-END: Session {SessionId} ended successfully", SessionId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "COPILOT-SESSION-END: Exception ending session {SessionId}", SessionId);
            Model.SessionStatus = "Active"; // Revert to previous status
            await ShowMessageAsync("Error ending session. Please check your connection and try again.");
        }
        finally
        {
            isLoading = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    /// <summary>
    /// [DEBUG-WORKITEM:assetshare:continue] Handle share button clicks from JavaScript
    /// </summary>
    [JSInvokable]
    public async Task ShareAsset(string shareId, string assetType, int instanceNumber)
    {
        var broadcastId = Guid.NewGuid().ToString("N")[..8];
        Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] 🚀🚀🚀 SHAREBUTTON CLICKED - C# METHOD CALLED! broadcastId={BroadcastId} ;CLEANUP_OK", broadcastId);
        Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] 📦 PHASE1 INPUT: ShareId={ShareId}, AssetType={AssetType}, Instance={InstanceNumber}, broadcastId={BroadcastId} ;CLEANUP_OK", shareId, assetType, instanceNumber, broadcastId);
        Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] 🎯 PHASE1 STEP 1/7: ShareAsset initiated, broadcastId={BroadcastId} ;CLEANUP_OK", broadcastId);
        Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] 🔍 DEBUGGING: Method successfully invoked from JavaScript! This proves the click handler is working! ;CLEANUP_OK");
        
        // TOASTR: Show immediate feedback that click was detected and C# method called
        await JSRuntime.InvokeVoidAsync("showNoorToast", 
            $"Processing share request for {assetType} #{instanceNumber}...", 
            "Share Button Clicked", 
            "info");
        Logger.LogInformation("[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: Share click notification shown to user, broadcastId={BroadcastId} ;CLEANUP_OK", broadcastId);
        
        if (SessionId == null || hubConnection == null)
        {
            var errorMsg = "Cannot share asset: SignalR connection or session not available";
            Logger.LogError("[DEBUG-WORKITEM:assetshare:continue] ❌ Precondition failed: SessionId={SessionId}, hubConnection={HubConnectionExists}", SessionId, hubConnection != null);
            
            // TOASTR: Show error notification
            await JSRuntime.InvokeVoidAsync("showNoorToast", 
                "Share failed: Session or SignalR connection not available. Please refresh the page.", 
                "Share Error", 
                "error");
            Logger.LogError("[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: Connection error notification shown, broadcastId={BroadcastId} ;CLEANUP_OK", broadcastId);
            
            await ShowErrorMessageAsync(errorMsg);
            return;
        }

        if (hubConnection.State != HubConnectionState.Connected)
        {
            var errorMsg = $"SignalR connection is in state: {hubConnection.State}. Expected: Connected";
            Logger.LogError("[DEBUG-WORKITEM:assetshare:continue] ❌ SignalR not connected: State={State}", hubConnection.State);
            
            // TOASTR: Show SignalR connection error
            await JSRuntime.InvokeVoidAsync("showNoorToast", 
                $"Share failed: SignalR is {hubConnection.State}. Please refresh the page to reconnect.", 
                "Connection Error", 
                "error");
            Logger.LogError("[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: SignalR state error notification shown, State={State}, broadcastId={BroadcastId} ;CLEANUP_OK", hubConnection.State, broadcastId);
            
            await ShowErrorMessageAsync(errorMsg);
            return;
        }

        try
        {
            // [KSESSIONS-STYLE FIX] Use direct content broadcasting - no complex JSON wrapping
            // Extract raw asset HTML directly from the source
            var rawAssetHtml = await ExtractRawAssetHtml(shareId, assetType, instanceNumber);
            
            if (string.IsNullOrEmpty(rawAssetHtml))
            {
                Logger.LogError("[ASSET-SHARE-KSESSIONS] ❌ No HTML content found for shareId: {ShareId}, broadcastId={BroadcastId}", shareId, broadcastId);
                
                // TOASTR: Show content not found error
                await JSRuntime.InvokeVoidAsync("showNoorToast", 
                    $"Could not find content for {assetType} #{instanceNumber}. The asset may have been removed or modified.", 
                    "Content Not Found", 
                    "error");
                Logger.LogError("[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: Content not found error shown, ShareId={ShareId}, broadcastId={BroadcastId} ;CLEANUP_OK", shareId, broadcastId);
                
                await ShowErrorMessageAsync($"Asset content not found for {assetType} #{instanceNumber}");
                return;
            }

            Logger.LogInformation("[ASSET-SHARE-KSESSIONS] ✅ STEP 2/4: Raw asset HTML extracted, length={Length} chars, broadcastId={BroadcastId}", rawAssetHtml.Length, broadcastId);
            Logger.LogInformation("[ASSET-SHARE-KSESSIONS] 📄 HTML PREVIEW: {HtmlPreview}, broadcastId={BroadcastId}", rawAssetHtml.Substring(0, Math.Min(200, rawAssetHtml.Length)), broadcastId);

            Logger.LogInformation("[ASSET-SHARE-KSESSIONS] 🚀 STEP 3/4: Broadcasting asset via KSESSIONS-style PublishAssetContent, target=session_{SessionId}, broadcastId={BroadcastId}", SessionId.Value, broadcastId);
            
            // [KSESSIONS PATTERN] Direct content broadcasting - no complex object wrapping
            var shareTask = hubConnection.InvokeAsync("PublishAssetContent", SessionId.Value, rawAssetHtml);
            var timeoutTask = Task.Delay(5000);
            
            var completedTask = await Task.WhenAny(shareTask, timeoutTask);
            
            if (completedTask == timeoutTask)
            {
                Logger.LogError("[ASSET-SHARE-KSESSIONS] ❌ STEP 3 FAILED: SignalR timeout after 5s, broadcastId={BroadcastId}", broadcastId);
                
                // TOASTR: Show timeout error
                await JSRuntime.InvokeVoidAsync("showNoorToast", 
                    $"Share request for {assetType} #{instanceNumber} timed out. Please check your connection and try again.", 
                    "Share Timeout", 
                    "error");
                Logger.LogError("[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: Timeout error notification shown, broadcastId={BroadcastId} ;CLEANUP_OK", broadcastId);
                
                await ShowErrorMessageAsync("Asset sharing timed out after 5 seconds");
                return;
            }

            await shareTask; // Await the actual task to catch any exceptions
            
            Logger.LogInformation("[ASSET-SHARE-KSESSIONS] ✅ STEP 4/4: KSESSIONS-style PublishAssetContent completed successfully, SessionId={SessionId}, broadcastId={BroadcastId}", SessionId.Value, broadcastId);
            
            // TOASTR: Show success notification with asset details
            await JSRuntime.InvokeVoidAsync("showNoorToast", 
                $"{assetType} #{instanceNumber} has been shared with all participants!", 
                "✅ Share Successful", 
                "success");
            Logger.LogInformation("[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: Success notification shown, AssetType={AssetType}, Instance={InstanceNumber}, broadcastId={BroadcastId} ;CLEANUP_OK", assetType, instanceNumber, broadcastId);
            
            await ShowSuccessMessageAsync($"✅ {assetType} #{instanceNumber} shared successfully via KSESSIONS pattern!");
            Logger.LogInformation("[ASSET-SHARE-KSESSIONS] 🎉 SHARE COMPLETE: Asset broadcasted using direct content approach, broadcastId={BroadcastId}", broadcastId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[ASSET-SHARE-KSESSIONS] ❌ Error in KSESSIONS-style asset sharing: {ShareId}, broadcastId={BroadcastId}", shareId, broadcastId);
            
            // TOASTR: Show exception error with user-friendly message
            await JSRuntime.InvokeVoidAsync("showNoorToast", 
                $"Failed to share {assetType} #{instanceNumber}: {ex.Message}", 
                "Share Failed", 
                "error");
            Logger.LogError("[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: Exception error notification shown, Exception={ExceptionType}, broadcastId={BroadcastId} ;CLEANUP_OK", ex.GetType().Name, broadcastId);
            
            await ShowErrorMessageAsync($"KSESSIONS-style asset sharing failed: {ex.Message}");
        }
    }
    
    private async Task TestShareAsset()
    {
        var broadcastId = Guid.NewGuid().ToString("N")[..8];
        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 🚀 TestShareAsset method called");
        Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] 🎯 STEP 1/7: TestShareAsset initiated, broadcastId={BroadcastId} ;CLEANUP_OK", broadcastId);
        
        if (SessionId == null || hubConnection == null) 
        {
            var errorMsg = "Cannot test asset sharing: SignalR connection or session not available";
            Logger.LogError("[DEBUG-WORKITEM:hostcanvas:HOST] ❌ Precondition failed: SessionId={SessionId}, hubConnection={HubConnectionExists}", SessionId, hubConnection != null);
            Logger.LogError("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] ❌ STEP 1 FAILED: Preconditions not met, broadcastId={BroadcastId} ;CLEANUP_OK", broadcastId);
            Logger.LogWarning("NOOR-TEST-ERROR: {ErrorMessage}", errorMsg);
            await ShowErrorMessageAsync(errorMsg);
            return;
        }

        if (hubConnection.State != HubConnectionState.Connected)
        {
            var errorMsg = $"SignalR connection is in state: {hubConnection.State}. Expected: Connected";
            Logger.LogError("[DEBUG-WORKITEM:hostcanvas:HOST] ❌ SignalR not connected: State={State}", hubConnection.State);
            Logger.LogError("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] ❌ STEP 1 FAILED: SignalR not connected, state={State}, broadcastId={BroadcastId} ;CLEANUP_OK", hubConnection.State, broadcastId);
            Logger.LogWarning("NOOR-TEST-ERROR: {ErrorMessage}", errorMsg);
            await ShowErrorMessageAsync(errorMsg);
            return;
        }

        try
        {
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] ✅ Preconditions passed: SessionId={SessionId}, ConnectionId={ConnectionId}", SessionId.Value, hubConnection.ConnectionId);
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] ✅ STEP 2/7: Preconditions validated, SessionId={SessionId}, ConnectionId={ConnectionId}, broadcastId={BroadcastId} ;CLEANUP_OK", SessionId.Value, hubConnection.ConnectionId, broadcastId);

            // NEW: Detect sharable assets using AssetLookup API and SessionTranscripts for session 212
            var assetDetectionResult = await DetectShareableAssetsAsync();
            
            // Create test asset with asset detection information
            var testId = Guid.NewGuid().ToString("N")[..8];
            var currentTime = DateTime.UtcNow.ToString("HH:mm:ss");
            
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 📊 Generated test asset: TestId={TestId}, Time={Time}", testId, currentTime);
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] 📦 STEP 3/7: Asset data created, testId={TestId}, time={Time}, broadcastId={BroadcastId} ;CLEANUP_OK", testId, currentTime, broadcastId);
            
            // Enhanced test HTML content with asset detection results
            var testHtmlContent = $@"<div style=""background:#E8F5E8;color:#006400;padding:20px;border-radius:8px;text-align:center;border:2px solid #006400;"">
<h3 style=""margin:0 0 10px 0;"">Test Asset Shared</h3>
<p style=""margin:5px 0;""><strong>Time:</strong> {System.Web.HttpUtility.HtmlEncode(currentTime)}</p>
<p style=""margin:5px 0;""><strong>Test ID:</strong> {System.Web.HttpUtility.HtmlEncode(testId)}</p>
<p style=""margin:5px 0;""><strong>Asset Detection:</strong> {System.Web.HttpUtility.HtmlEncode(assetDetectionResult)}</p>
<p style=""margin:10px 0 0 0;font-size:14px;"">SignalR connection working!</p>
</div>";

            var testAssetData = new
            {
                testContent = testHtmlContent,
                shareId = testId,
                timestamp = DateTime.UtcNow
            };

            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 📦 Test asset payload created: shareId={ShareId}, htmlLength={HtmlLength} chars", testId, testHtmlContent.Length);
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] 📋 STEP 4/7: HTML payload assembled, contentLength={Length} chars, shareId={ShareId}, broadcastId={BroadcastId} ;CLEANUP_OK", testHtmlContent.Length, testId, broadcastId);
            Logger.LogDebug("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] Payload preview: {PayloadPreview} ;CLEANUP_OK", 
                testHtmlContent.Substring(0, Math.Min(100, testHtmlContent.Length)));

            // Send via SignalR with timeout
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 🔄 Invoking ShareAsset on hub: SessionId={SessionId}, Group=session_{SessionId}", SessionId.Value, SessionId.Value);
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] 🚀 STEP 5/7: Initiating SignalR ShareAsset call, target=session_{SessionId}, broadcastId={BroadcastId} ;CLEANUP_OK", SessionId.Value, broadcastId);
            var shareTask = hubConnection.InvokeAsync("ShareAsset", SessionId.Value, testAssetData);
            var timeoutTask = Task.Delay(5000); // 5 second timeout
            
            var completedTask = await Task.WhenAny(shareTask, timeoutTask);
            
            if (completedTask == timeoutTask)
            {
                var errorMsg = "ShareAsset operation timed out after 5 seconds";
                Logger.LogError("[DEBUG-WORKITEM:hostcanvas:HOST] ⏰ SignalR call timed out after 5 seconds");
                Logger.LogError("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] ❌ STEP 5 FAILED: SignalR timeout after 5s, broadcastId={BroadcastId} ;CLEANUP_OK", broadcastId);
                await ShowErrorMessageAsync(errorMsg);
                return;
            }

            // If we reach here, ShareAsset completed successfully
            await shareTask; // Await the actual task to catch any exceptions
            
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 🎉 ShareAsset SignalR call completed successfully!");
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] 📡 Asset should now be broadcasted to all SessionCanvas clients in group session_{SessionId}", SessionId.Value);
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] ✅ STEP 6/7: SignalR ShareAsset call completed successfully, SessionId={SessionId}, broadcastId={BroadcastId} ;CLEANUP_OK", SessionId.Value, broadcastId);
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:BROADCAST-TRACK] 📡 STEP 7/7: Broadcast should now reach SessionCanvas clients in group session_{SessionId}, broadcastId={BroadcastId} ;CLEANUP_OK", SessionId.Value, broadcastId);
            await ShowSuccessMessageAsync("✅ Test asset shared successfully via SignalR!");
        }
        catch (TimeoutException ex)
        {
            var errorMsg = "ShareAsset operation timed out";
            Logger.LogError(ex, "NOOR-TEST-ERROR: {ErrorMessage} for session {SessionId}", errorMsg, SessionId);
            await ShowErrorMessageAsync($"{errorMsg}: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("showErrorPanel", $"{errorMsg}: {ex.Message}", ex.ToString());
        }
        catch (HubException ex)
        {
            var errorMsg = "SignalR Hub error during asset sharing";
            Logger.LogError(ex, "NOOR-TEST-ERROR: {ErrorMessage} for session {SessionId}", errorMsg, SessionId);
            await ShowErrorMessageAsync($"{errorMsg}: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("showErrorPanel", $"{errorMsg}: {ex.Message}", ex.ToString());
        }
        catch (InvalidOperationException ex)
        {
            var errorMsg = "Invalid operation during asset sharing";
            Logger.LogError(ex, "NOOR-TEST-ERROR: {ErrorMessage} for session {SessionId}", errorMsg, SessionId);
            await ShowErrorMessageAsync($"{errorMsg}: {ex.Message}");
            await JSRuntime.InvokeVoidAsync("showErrorPanel", $"{errorMsg}: {ex.Message}", ex.ToString());
        }
        catch (Exception ex)
        {
            var errorMsg = "Unexpected error during asset sharing";
            Logger.LogError(ex, "NOOR-TEST-ERROR: {ErrorMessage} for session {SessionId}", errorMsg, SessionId);
            await ShowErrorMessageAsync($"{errorMsg}: {ex.Message}");
            
            // Also show in error panel for debugging
            await JSRuntime.InvokeVoidAsync("showErrorPanel", $"{errorMsg}: {ex.Message}", ex.ToString());
        }
    }

    /// <summary>
    /// Detect the number of sharable assets using AssetLookup API and SessionTranscripts for session 212
    /// </summary>
    private async Task<string> DetectShareableAssetsAsync()
    {
        try
        {
            Logger.LogInformation("[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] 🔍 Starting asset detection for session 212");
            
            // Step 1: Get AssetLookup definitions from API
            using var httpClient = HttpClientFactory.CreateClient("default");
            var assetLookupResponse = await httpClient.GetAsync("/api/host/asset-lookup");
            
            if (!assetLookupResponse.IsSuccessStatusCode)
            {
                Logger.LogWarning("[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] ❌ Failed to get AssetLookup data: {StatusCode}", assetLookupResponse.StatusCode);
                return "AssetLookup API Error";
            }

            var assetLookupContent = await assetLookupResponse.Content.ReadAsStringAsync();
            var assetLookups = JsonSerializer.Deserialize<List<AssetLookupDto>>(assetLookupContent, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            }) ?? new List<AssetLookupDto>();

            Logger.LogInformation("[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] 📋 Loaded {Count} asset lookup definitions", assetLookups.Count);

            // Step 2: Get SessionTranscripts for session 212
            var sessionDetailsResponse = await httpClient.GetAsync("/api/host/session-details/212?guid=debug-asset-detection");
            
            if (!sessionDetailsResponse.IsSuccessStatusCode)
            {
                Logger.LogWarning("[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] ❌ Failed to get session 212 details: {StatusCode}", sessionDetailsResponse.StatusCode);
                return "Session 212 API Error";
            }

            var sessionDetailsContent = await sessionDetailsResponse.Content.ReadAsStringAsync();
            var sessionDetails = JsonSerializer.Deserialize<EnhancedSessionDetailsApiResponse>(sessionDetailsContent, new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            });

            if (sessionDetails?.Session == null)
            {
                Logger.LogWarning("[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] ❌ No session details found for session 212");
                return "Session 212 Not Found";
            }

            var transcript = sessionDetails.Session.Transcript ?? "";
            Logger.LogInformation("[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] 📄 Retrieved transcript, length: {Length} chars", transcript.Length);

            // Step 3: Count assets found in transcript using AssetLookup CSS selectors
            var parser = new AngleSharp.Html.Parser.HtmlParser();
            var document = parser.ParseDocument(transcript);
            int totalAssetsFound = 0;
            var assetCounts = new List<string>();

            foreach (var lookup in assetLookups.Where(a => a.IsActive && !string.IsNullOrEmpty(a.CssSelector)))
            {
                var elements = document.QuerySelectorAll(lookup.CssSelector ?? "");
                if (elements.Length > 0)
                {
                    totalAssetsFound += elements.Length;
                    assetCounts.Add($"{lookup.DisplayName ?? lookup.AssetIdentifier}: {elements.Length}");
                    
                    Logger.LogInformation("[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] 🎯 Found {Count} instances of {AssetType} using selector '{Selector}'", 
                        elements.Length, lookup.AssetIdentifier, lookup.CssSelector);
                }
            }

            Logger.LogInformation("[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] ✅ Asset detection complete: {Total} total assets found in session 212", totalAssetsFound);
            
            if (totalAssetsFound == 0)
            {
                return "No sharable assets found in session 212";
            }
            
            return $"Found {totalAssetsFound} sharable assets in session 212: {string.Join(", ", assetCounts)}";
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:hostcontrolpanel:ASSET-DETECTION] ❌ Exception during asset detection");
            return $"Asset detection failed: {ex.Message}";
        }
    }

    // SignalR Status Methods
    private string GetSignalRStatusIcon()
    {
        return hubConnection?.State switch
        {
            HubConnectionState.Connected => "fa-solid fa-circle-check",
            HubConnectionState.Connecting => "fa-solid fa-circle-notch fa-spin",
            HubConnectionState.Reconnecting => "fa-solid fa-arrows-rotate fa-spin",
            HubConnectionState.Disconnected => "fa-solid fa-circle-xmark",
            _ => "fa-solid fa-circle-question"
        };
    }

    private string GetSignalRStatusColor()
    {
        return hubConnection?.State switch
        {
            HubConnectionState.Connected => "#10B981",      // Green
            HubConnectionState.Connecting => "#F59E0B",     // Yellow  
            HubConnectionState.Reconnecting => "#F59E0B",   // Yellow
            HubConnectionState.Disconnected => "#EF4444",  // Red
            _ => "#6B7280"                                  // Gray
        };
    }

    private string GetSignalRStatusText()
    {
        return hubConnection?.State switch
        {
            HubConnectionState.Connected => "Connected to SignalR Hub",
            HubConnectionState.Connecting => "Connecting to SignalR Hub",
            HubConnectionState.Reconnecting => "Reconnecting to SignalR Hub",
            HubConnectionState.Disconnected => "Disconnected from SignalR Hub",
            _ => "SignalR Hub Status Unknown"
        };
    }

    private void NavigateToSessionCanvas()
    {
        if (!string.IsNullOrEmpty(UserToken))
        {
            var requestId = Guid.NewGuid().ToString("N")[..8];
            Logger.LogInformation("[DEBUG-WORKITEM:canvas:UI] [{RequestId}] Host navigating to SessionCanvas with UserToken: {UserToken}", requestId, UserToken);
            Navigation.NavigateTo($"/session/canvas/{UserToken}");
        }
        else
        {
            Logger.LogWarning("[DEBUG-WORKITEM:canvas:UI] NavigateToSessionCanvas called but UserToken is null or empty");
        }
    }

    private async Task MarkQuestionAnswered(Guid questionId)
    {
        var question = Model?.Questions?.FirstOrDefault(q => q.Id == questionId);
        if (question != null)
        {
            question.IsAnswered = true;
            await InvokeAsync(StateHasChanged);
            
            // Notify via SignalR
            if (hubConnection?.State == HubConnectionState.Connected)
            {
                await hubConnection.InvokeAsync("NotifyQuestionAnswered", SessionId, questionId);
            }
        }
    }

    private async Task ShowDeleteModal(Guid questionId)
    {
        questionToDeleteId = questionId;
        showDeleteModal = true;
        await InvokeAsync(StateHasChanged);
    }

    private async Task ConfirmDelete()
    {
        Model?.Questions?.RemoveAll(q => q.Id == questionToDeleteId);
        showDeleteModal = false;
        await InvokeAsync(StateHasChanged);
        
        // Notify via SignalR
        if (hubConnection?.State == HubConnectionState.Connected)
        {
            await hubConnection.InvokeAsync("NotifyQuestionDeleted", SessionId, questionToDeleteId);
        }
    }

    private async Task CancelDelete()
    {
        showDeleteModal = false;
        await InvokeAsync(StateHasChanged);
    }

    private async Task ShowMessageAsync(string message)
    {
        messageText = message;
        showMessage = true;
        await InvokeAsync(StateHasChanged);

        messageTimer?.Dispose();
        messageTimer = new Timer(async _ =>
        {
            showMessage = false;
            await InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(3), Timeout.InfiniteTimeSpan);
    }

    private async Task ShowSuccessMessageAsync(string message)
    {
        messageText = message;
        showMessage = true;
        await InvokeAsync(StateHasChanged);

        messageTimer?.Dispose();
        messageTimer = new Timer(async _ =>
        {
            showMessage = false;
            await InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(4), Timeout.InfiniteTimeSpan);
    }

    private async Task ShowErrorMessageAsync(string message)
    {
        messageText = $"❌ {message}";
        showMessage = true;
        await InvokeAsync(StateHasChanged);

        messageTimer?.Dispose();
        messageTimer = new Timer(async _ =>
        {
            showMessage = false;
            await InvokeAsync(StateHasChanged);
        }, null, TimeSpan.FromSeconds(6), Timeout.InfiniteTimeSpan);
    }

    /// <summary>
    /// Initialize share button handlers when SessionId becomes available (initial setup only)
    /// </summary>
    private async Task InitializeShareButtonHandlersAsync()
    {
        if (!SessionId.HasValue)
        {
            Logger.LogDebug("[DEBUG-WORKITEM:assetshare:continue] Skipping share handler initialization - no SessionId ;CLEANUP_OK");
            return;
        }

        try
        {
            Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Initializing share button handlers for SessionId: {SessionId} ;CLEANUP_OK", SessionId);
            
            // Set SessionId in JavaScript (only needs to be done once)
            await JSRuntime.InvokeVoidAsync("eval", $"window.currentSessionId = {SessionId.Value};");
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:HOST] ✅ Set JavaScript window.currentSessionId = {SessionId}", SessionId.Value);
            
            // Initialize the new definitive share system - simple and reliable
            var dotNetRef = DotNetObjectReference.Create(this);
            var initResult = await JSRuntime.InvokeAsync<bool>("initNoorShareSystem", dotNetRef);
            
            if (initResult)
            {
                shareHandlersInitialized = true;
                Logger.LogInformation("[NOOR-SHARE] ✅ Share system initialized successfully");
                
                // Get status for debugging
                var status = await JSRuntime.InvokeAsync<object>("getNoorShareStatus");
                Logger.LogInformation("[NOOR-SHARE] System status: {Status}", status);
            }
            else
            {
                Logger.LogError("[NOOR-SHARE] ❌ Failed to initialize share system");
            }
            
            // Check if share buttons exist in the DOM at this point (may be zero initially)
            var buttonCount = await JSRuntime.InvokeAsync<int>("eval", "document.querySelectorAll('[data-share-button=\"asset\"]').length");
            Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Found {ButtonCount} share buttons in DOM after setup ;CLEANUP_OK", buttonCount);
            
            // Note: shareHandlersInitialized flag is set in InitializeHandlersWithTimerAsync when timer starts
            Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Timer-based handler initialization completed ;CLEANUP_OK");
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:assetshare:continue] Failed to initialize share button handlers ;CLEANUP_OK");
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // [DEBUG-WORKITEM:assetshare:fix] Always try to initialize share handlers when component renders and SessionId is available
        if (SessionId.HasValue)
        {
            await InitializeShareButtonHandlersAsync();
        }
        
        // [DEBUG-WORKITEM:hostcanvas:impl] Legacy first render logic for backward compatibility ;CLEANUP_OK
        if (firstRender && SessionId.HasValue)
        {
            Logger.LogInformation("[DEBUG-WORKITEM:hostcanvas:impl] First render completed with SessionId = {SessionId} ;CLEANUP_OK", SessionId.Value);
        }
        
        // [DEBUG-WORKITEM:sharebutton-debug:fix] CRITICAL FIX: Reinitialize share button handlers after transcript content is rendered
        if (!firstRender && !string.IsNullOrEmpty(Model?.TransformedTranscript) && SessionId.HasValue)
        {
            Logger.LogInformation("NOOR-HTML-VIEWER: Transcript rendered successfully ({Length} chars)", Model.TransformedTranscript.Length);
            
            // TIMING FIX: Use a small delay to ensure DOM content is fully rendered before attaching handlers
            await Task.Delay(50); // Allow DOM to complete rendering
            await ReinitializeShareButtonHandlersAsync();
        }
        await Task.CompletedTask;
    }
    
    /// <summary>
    /// Reinitialize share button handlers after transcript content changes - CRITICAL timing fix with retry logic
    /// </summary>
    private async Task ReinitializeShareButtonHandlersAsync()
    {
        if (!SessionId.HasValue)
        {
            Logger.LogDebug("[DEBUG-WORKITEM:sharebutton-debug:fix] Skipping handler reinitialization - no SessionId ;CLEANUP_OK");
            return;
        }

        // Prevent duplicate reinitializations within the same render cycle
        if (shareHandlersInitialized)
        {
            Logger.LogDebug("[DEBUG-WORKITEM:sharebutton-debug:fix] Skipping reinitialization - handlers already initialized for this cycle ;CLEANUP_OK");
            return;
        }

        try
        {
            Logger.LogInformation("[NOOR-SHARE] 🔄 Reinitializing share system after transcript update");
            
            // Count existing share buttons
            var buttonCount = await JSRuntime.InvokeAsync<int>("eval", "document.querySelectorAll('.ks-share-button, .ks-share-btn').length");
            Logger.LogInformation("[NOOR-SHARE] 🔍 Found {ButtonCount} share buttons in DOM", buttonCount);
            
            // Initialize the new definitive share system
            await InitializeNoorShareSystemAsync();
            
            // Refresh button styling if buttons exist
            if (buttonCount > 0)
            {
                await JSRuntime.InvokeVoidAsync("refreshShareButtons");
                Logger.LogInformation("[NOOR-SHARE] 🎨 Refreshed styling for {ButtonCount} buttons", buttonCount);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NOOR-SHARE] ❌ Failed to reinitialize share system");
        }
    }

    /// <summary>
    /// Initialize the definitive share system - simple and reliable
    /// </summary>
    private async Task InitializeNoorShareSystemAsync()
    {
        try
        {
            Logger.LogInformation("[NOOR-SHARE] Starting definitive share system initialization");
            
            var dotNetRef = DotNetObjectReference.Create(this);
            var initResult = await JSRuntime.InvokeAsync<bool>("initNoorShareSystem", dotNetRef);
            
            if (initResult)
            {
                shareHandlersInitialized = true;
                Logger.LogInformation("[NOOR-SHARE] ✅ Definitive share system initialized successfully");
            }
            else
            {
                Logger.LogError("[NOOR-SHARE] ❌ Failed to initialize definitive share system");
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[NOOR-SHARE] ❌ Exception during share system initialization");
        }
    }

    /// <summary>
    /// Extract HTML content for a specific asset using the shareId to locate it in the transcript
    /// </summary>
    /// <summary>
    /// [FIX] Simplified raw HTML extraction inspired by KSessions pattern
    /// Extracts asset HTML directly without complex processing to prevent appendChild errors
    /// </summary>
    private Task<string> ExtractRawAssetHtml(string shareId, string assetType, int instanceNumber)
    {
        try
        {
            if (string.IsNullOrEmpty(Model?.SessionTranscript))
            {
                Logger.LogError("[DEBUG-WORKITEM:assetshare:continue] SessionTranscript is null or empty");
                return Task.FromResult(string.Empty);
            }

            Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Extracting raw asset HTML using simple pattern matching: {AssetType}", assetType);
            
            // [FIX] Use simple HTML parsing to extract asset content directly from original transcript
            var htmlDoc = new HtmlAgilityPack.HtmlDocument();
            htmlDoc.LoadHtml(Model.SessionTranscript);
            
            // Find ayah-card elements (or other asset types) directly
            var assetElements = htmlDoc.DocumentNode.SelectNodes("//div[contains(@class, 'ayah-card')]");
            
            if (assetElements != null && assetElements.Count > instanceNumber - 1)
            {
                var targetElement = assetElements[instanceNumber - 1];
                var rawHtml = targetElement.OuterHtml;
                
                Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Successfully extracted raw asset HTML: {Length} chars", rawHtml.Length);
                return Task.FromResult(rawHtml);
            }
            else
            {
                Logger.LogWarning("[DEBUG-WORKITEM:assetshare:continue] Asset element not found: {AssetType} instance {Instance}", assetType, instanceNumber);
                return Task.FromResult(string.Empty);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:assetshare:continue] Error extracting raw asset HTML: {AssetType}", assetType);
            return Task.FromResult(string.Empty);
        }
    }

    private Task<string> ExtractAssetHtmlContent(string shareId, string assetType, int instanceNumber)
    {
        try
        {
            if (string.IsNullOrEmpty(Model?.TransformedTranscript))
            {
                Logger.LogError("[DEBUG-WORKITEM:assetshare:continue] TransformedTranscript is null or empty");
                return Task.FromResult(string.Empty);
            }

            Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Extracting asset with AssetHtmlProcessingService: {ShareId}", shareId);
            
            // Use the AssetProcessor service to extract the asset HTML
            // Note: AssetHtmlProcessor functionality moved to AssetProcessingService
            var extractResult = new { HtmlContent = "" }; // Simplified for now
            
            if (extractResult != null && !string.IsNullOrEmpty(extractResult.HtmlContent))
            {
                Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Successfully extracted asset HTML: {Length} chars", extractResult.HtmlContent.Length);
                return Task.FromResult(extractResult.HtmlContent);
            }
            else
            {
                Logger.LogWarning("[DEBUG-WORKITEM:assetshare:continue] AssetHtmlProcessor returned empty result for: {ShareId}", shareId);
                return Task.FromResult(string.Empty);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:assetshare:continue] Error extracting asset HTML for shareId: {ShareId}", shareId);
            return Task.FromResult(string.Empty);
        }
    }

    /// <summary>
    /// Process asset HTML for sharing using AssetHtmlProcessingService
    /// </summary>
    private Task<string> ProcessAssetForSharing(string assetHtml, string assetType)
    {
        try
        {
            Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Processing asset HTML for sharing, type: {AssetType}", assetType);
            
            // Use AssetProcessingService to process the HTML for sharing
            // Note: AssetHtmlProcessor functionality moved to AssetProcessingService
            var processResult = new { ProcessedHtml = assetHtml }; // Simplified for now
            
            if (processResult != null && !string.IsNullOrEmpty(processResult.ProcessedHtml))
            {
                Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue] Asset HTML processed successfully: {Length} chars", processResult.ProcessedHtml.Length);
                return Task.FromResult(processResult.ProcessedHtml);
            }
            else
            {
                Logger.LogWarning("[DEBUG-WORKITEM:assetshare:continue] AssetHtmlProcessor returned null or empty result, using original HTML");
                return Task.FromResult(assetHtml);
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:assetshare:continue] Error processing asset HTML, using original: {AssetType}", assetType);
            return Task.FromResult(assetHtml);
        }
    }

    public async ValueTask DisposeAsync()
    {
        messageTimer?.Dispose();
        
        if (hubConnection != null)
        {
            await hubConnection.DisposeAsync();
        }
    }

    // ViewModel Classes moved to NoorCanvas.ViewModels namespace






    




    private string GetLogEntryColor(string level)
    {
        return level.ToUpper() switch
        {
            "ERROR" => "#EF4444",
            "WARN" => "#F59E0B", 
            "SUCCESS" => "#10B981",
            "SIGNALR" => "#8B5CF6",
            "DATA" => "#06B6D4",
            _ => "#E5E7EB"
        };
    }

    /// <summary>
    /// Transforms the transcript HTML by removing delete buttons and adding SHARE buttons for each asset
    /// Share buttons are only injected when session status is "Active"
    /// </summary>
    private async Task<string> TransformTranscriptHtmlAsync(string originalHtml)
    {
        if (string.IsNullOrEmpty(originalHtml))
        {
            return originalHtml ?? string.Empty;
        }

        try
        {
            Logger.LogDebug("COPILOT-DEBUG: [HostControlPanel:TransformTranscriptHtml] Starting HTML transformation for SessionId {SessionId}, SessionStatus: {SessionStatus}", 
                SessionId, Model?.SessionStatus);
            
            bool shouldInjectButtons = !string.IsNullOrEmpty(originalHtml) && SessionId.HasValue && 
                                     (Model?.SessionStatus == "Active" || Model?.SessionStatus == "Waiting");

            // [DEBUG-WORKITEM:sharebutton-debug:fix] Reset handlers flag when content changes to allow reinitialization
            shareHandlersInitialized = false;
            Logger.LogDebug("[DEBUG-WORKITEM:sharebutton-debug:fix] Reset shareHandlersInitialized flag for new transcript content ;CLEANUP_OK");

            // Use AssetProcessingService for transformation
            return await AssetProcessor.TransformTranscriptHtmlAsync(originalHtml, SessionId, Model?.SessionStatus);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "COPILOT-DEBUG: [HostControlPanel:TransformTranscriptHtml] Exception: {Message}", ex.Message);
            return originalHtml ?? string.Empty; // Return original HTML if transformation fails
        }
    }

    // Asset processing methods moved to AssetProcessingService

    /// <summary>
    /// Enhanced debug method to test AssetLookup table and asset detection with comprehensive popup display
    /// </summary>
    private async Task TestAssetDetectionAsync()
    {
        var runId = DateTime.Now.ToString("HHmmss") + "-TEST";
        try
        {
            Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue:{RunId}] === ENHANCED ASSET DETECTION TEST === ;CLEANUP_OK", runId);
            
            // Get asset lookups from API
            var assetLookups = await AssetProcessor.GetAssetLookupsFromApiAsync(runId);
            if (assetLookups == null || assetLookups.Count == 0)
            {
                await ShowErrorPopup("No asset definitions found", "The asset lookup API returned no definitions. Please check the AssetLookup table has data.");
                return;
            }

            // Test HTML with ayah-card from user's attachment
            var testHtml = @"<div class=""ayah-card"" id=""ayah-card-14-34"">
                <div class=""golden-surah-header clickable-ayah-header"" data-ayats=""34"" data-original-token=""Q|14:34"" data-surah=""14"" id=""ayah-header-14-34"">
                    <span>Abraham (14:34)</span>
                </div>
                <p class=""ayah-arabic"">Test Arabic text</p>
                <div class=""translation-header"">Translation:</div>
                <p class=""ayah-translation"">Test translation text</p>
            </div>";

            // Analyze current session transcript if available
            string currentTranscript = Model?.SessionTranscript ?? "";
            
            // Count assets in both test HTML and current transcript  
            var testResults = AnalyzeAssetDetection(testHtml, assetLookups, "Test HTML");
            var transcriptResults = AnalyzeAssetDetection(currentTranscript, assetLookups, "Current Session Transcript");
            
            // Show results popup
            await ShowAssetDetectionResults(testResults, transcriptResults, assetLookups.Count);
            
            Logger.LogInformation("[DEBUG-WORKITEM:assetshare:continue:{RunId}] Enhanced asset detection completed successfully ;CLEANUP_OK", runId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:assetshare:continue:{RunId}] Enhanced asset detection failed ;CLEANUP_OK", runId);
            await ShowErrorPopup("Asset Detection Failed", $"Error: {ex.Message}");
        }
    }

    /// <summary>
    /// Analyze asset detection for a given text content
    /// </summary>
    private AssetDetectionResult AnalyzeAssetDetection(string content, List<Controllers.AssetLookupDto> assetLookups, string sourceName)
    {
        var result = new AssetDetectionResult { SourceName = sourceName };
        
        if (string.IsNullOrEmpty(content))
        {
            return result;
        }

        foreach (var asset in assetLookups)
        {
            if (!string.IsNullOrEmpty(asset.CssSelector))
            {
                // Count occurrences of the CSS selector in the content
                var count = CountOccurrences(content, asset.CssSelector);
                if (count > 0)
                {
                    // Generate asset IDs for each occurrence (matching the share button pattern)
                    var generatedIds = new List<string>();
                    for (int i = 1; i <= count; i++)
                    {
                        generatedIds.Add($"asset-{asset.AssetIdentifier}-{i}");
                    }
                    
                    result.DetectedAssets.Add(new DetectedAsset
                    {
                        AssetId = (int)asset.AssetId,
                        Name = asset.DisplayName ?? "Unknown",
                        CssSelector = asset.CssSelector ?? "",
                        Count = count,
                        Description = asset.AssetType,
                        GeneratedAssetIds = generatedIds
                    });
                }
            }
        }
        
        result.TotalAssetsDetected = result.DetectedAssets.Count;
        return result;
    }

    /// <summary>
    /// Count occurrences of a pattern in text (case-insensitive)
    /// </summary>
    private int CountOccurrences(string text, string pattern)
    {
        if (string.IsNullOrEmpty(text) || string.IsNullOrEmpty(pattern))
            return 0;
            
        int count = 0;
        int index = 0;
        
        while ((index = text.IndexOf(pattern, index, StringComparison.OrdinalIgnoreCase)) != -1)
        {
            count++;
            index += pattern.Length;
        }
        
        return count;
    }

    /// <summary>
    /// Display asset detection results using custom modern HTML popup with rich styling
    /// </summary>
    private async Task ShowAssetDetectionResults(AssetDetectionResult testResults, AssetDetectionResult transcriptResults, int totalAssetDefinitions)
    {
        var runId = DateTime.Now.ToString("HHmmss");
        
        try 
        {
            // Build rich HTML content with modern styling
            var htmlContent = BuildModernAssetDetectionContent(testResults, transcriptResults, totalAssetDefinitions);
            
            Logger.LogInformation("[DEBUG-WORKITEM:popup:attempt:{RunId}] Attempting to show custom popup with {ContentLength} characters ;CLEANUP_OK", 
                runId, htmlContent?.Length ?? 0);
            
            // Show custom HTML popup using SweetAlert2
            await JSRuntime.InvokeVoidAsync("showCustomAssetPopup", htmlContent, "🔍 Enhanced Asset Detection Analysis");
            
            Logger.LogInformation("[DEBUG-WORKITEM:popup:success:{RunId}] SweetAlert2 popup invoked successfully ;CLEANUP_OK", runId);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:popup:failed:{RunId}] Custom popup failed: {ErrorMessage}, using fallback alert ;CLEANUP_OK", 
                runId, ex.Message);
            await ShowFallbackAssetAlert(testResults, transcriptResults, totalAssetDefinitions);
        }
    }

    /// <summary>
    /// Show fallback alert if custom popup fails
    /// </summary>
    private async Task ShowFallbackAssetAlert(AssetDetectionResult testResults, AssetDetectionResult transcriptResults, int totalAssetDefinitions)
    {
        try
        {
            var message = CreateAssetSummaryMessage(testResults, transcriptResults, totalAssetDefinitions);
            await JSRuntime.InvokeVoidAsync("alert", message);
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:popup:fallback] Both custom and alert failed ;CLEANUP_OK");
            LogAssetDetectionFallback(testResults, transcriptResults, totalAssetDefinitions);
        }
    }

    /// <summary>
    /// Create formatted asset detection summary message
    /// </summary>
    private static string CreateAssetSummaryMessage(AssetDetectionResult testResults, AssetDetectionResult transcriptResults, int totalAssetDefinitions)
    {
        var totalFound = testResults.TotalAssetsDetected + transcriptResults.TotalAssetsDetected;
        var timestamp = DateTime.Now.ToString("HH:mm:ss");
        
        return $"🔍 Asset Detection Complete\\n\\n" +
               $"📊 Available Types: {totalAssetDefinitions}\\n" +
               $"🧪 Test HTML: {testResults.TotalAssetsDetected} detected\\n" +
               $"🔴 Live Session: {transcriptResults.TotalAssetsDetected} detected\\n" +
               $"📈 Total Found: {totalFound}\\n\\n" +
               $"⏰ Completed at {timestamp}";
    }

    /// <summary>
    /// Log asset detection results when UI display fails
    /// </summary>
    private void LogAssetDetectionFallback(AssetDetectionResult testResults, AssetDetectionResult transcriptResults, int totalAssetDefinitions)
    {
        var totalFound = testResults.TotalAssetsDetected + transcriptResults.TotalAssetsDetected;
        Logger.LogInformation("Asset Detection Summary - Available:{Available} Test:{Test} Session:{Session} Total:{Total}", 
            totalAssetDefinitions, testResults.TotalAssetsDetected, transcriptResults.TotalAssetsDetected, totalFound);
    }

    /// <summary>
    /// Build modern styled HTML content for asset detection popup
    /// </summary>
    private string BuildModernAssetDetectionContent(AssetDetectionResult testResults, AssetDetectionResult transcriptResults, int totalAssetDefinitions)
    {
        var content = "<style>";
        // Modern theme matching NOOR Canvas application colors
        content += ".asset-detection-content { font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif; line-height: 1.6; }";
        content += ".asset-summary { background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 50%, #ec4899 100%); color: white; padding: 24px; border-radius: 16px; margin-bottom: 28px; box-shadow: 0 8px 32px rgba(79, 70, 229, 0.3); }";
        content += ".asset-card { background: linear-gradient(145deg, #ffffff 0%, #f8fafc 100%); border: 1px solid #e2e8f0; border-radius: 12px; padding: 20px; margin-bottom: 16px; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); box-shadow: 0 2px 8px rgba(0, 0, 0, 0.06); }";
        content += ".asset-card:hover { border-color: #4f46e5; transform: translateY(-4px); box-shadow: 0 8px 25px rgba(79, 70, 229, 0.15); }";
        content += ".asset-type { background: linear-gradient(135deg, #4f46e5, #7c3aed); color: white; padding: 6px 14px; border-radius: 24px; font-size: 0.8em; font-weight: 600; letter-spacing: 0.5px; }";
        content += ".asset-count { background: linear-gradient(135deg, #059669, #10b981); color: white; padding: 5px 12px; border-radius: 20px; font-size: 0.8em; font-weight: 600; }";
        content += ".asset-ids { background: linear-gradient(145deg, #f1f5f9, #e2e8f0); border: 1px solid #cbd5e1; padding: 12px; border-radius: 8px; font-family: 'SF Mono', 'Monaco', 'Cascadia Code', monospace; font-size: 0.85em; margin-top: 12px; color: #475569; }";
        content += ".section-header { font-size: 1.3em; font-weight: 700; color: #1e293b; margin: 28px 0 18px 0; border-bottom: 3px solid #e5e7eb; padding-bottom: 10px; display: flex; align-items: center; }";
        content += ".icon { margin-right: 10px; }";
        content += ".no-assets { color: #64748b; font-style: italic; text-align: center; padding: 32px; background: #f8fafc; border-radius: 12px; border: 2px dashed #cbd5e1; }";
        content += ".timestamp { text-align: center; color: #64748b; font-size: 0.9em; margin-top: 32px; padding-top: 20px; border-top: 2px solid #f1f5f9; font-weight: 500; }";
        content += ".stats-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; }";
        content += ".stat-item { text-align: center; padding: 16px; background: rgba(255,255,255,0.2); border-radius: 12px; }";
        content += ".stat-number { font-size: 2.2em; font-weight: 800; margin-bottom: 4px; }";
        content += ".stat-label { font-size: 0.9em; opacity: 0.9; font-weight: 500; }";
        content += "</style>";
        
        // Modern summary section with enhanced styling
        content += "<div class='asset-detection-content'>";
        content += "<div class='asset-summary'>";
        content += "<div style='display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;'>";
        content += "<div style='display: flex; align-items: center;'><span class='icon' style='font-size: 1.3em;'>📊</span><span style='font-size: 1.4em; font-weight: 700;'>Detection Summary</span></div>";
        content += "<div style='font-size: 1.8em; font-weight: 800; text-shadow: 0 2px 4px rgba(0,0,0,0.1);'>"+$"{testResults.TotalAssetsDetected + transcriptResults.TotalAssetsDetected}"+ " Found</div>";
        content += "</div>";
        content += "<div class='stats-grid'>";
        content += $"<div class='stat-item'><div class='stat-number'>{totalAssetDefinitions}</div><div class='stat-label'>Available Types</div></div>";
        content += $"<div class='stat-item'><div class='stat-number'>{testResults.TotalAssetsDetected}</div><div class='stat-label'>Test HTML</div></div>";
        content += $"<div class='stat-item'><div class='stat-number'>{transcriptResults.TotalAssetsDetected}</div><div class='stat-label'>Live Session</div></div>";
        content += "</div></div>";
        
        // Test HTML Results Section
        content += "<div class='section-header'><span class='icon'>🧪</span>Test HTML Analysis</div>";
        content += BuildAssetSection(testResults, "test-html");
        
        // Current Session Results Section
        content += "<div class='section-header'><span class='icon'>🔴</span>Live Session Analysis</div>";
        content += BuildAssetSection(transcriptResults, "live-session");
        
        // Timestamp
        content += $"<div class='timestamp'><span class='icon'>⏱️</span>Analysis completed at {DateTime.Now:yyyy-MM-dd HH:mm:ss}</div>";
        content += "</div>"; // Close asset-detection-content
        
        return content;
    }

    /// <summary>
    /// Build asset section with detailed asset cards
    /// </summary>
    private string BuildAssetSection(AssetDetectionResult results, string sectionId)
    {
        if (!results.DetectedAssets.Any())
        {
            return "<div class='no-assets'><span class='icon'>❌</span>No assets detected in this content</div>";
        }
        
        var section = "<div class='assets-grid'>";
        
        foreach (var asset in results.DetectedAssets)
        {
            section += "<div class='asset-card'>";
            
            // Asset header with type and count
            section += "<div style='display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;'>";
            section += $"<div><span class='icon'>🎯</span><strong>{asset.Name}</strong></div>";
            section += $"<span class='asset-count'>{asset.Count} found</span>";
            section += "</div>";
            
            // Asset details
            section += "<div style='margin-bottom: 10px;'>";
            section += $"<span class='asset-type'>{asset.Description}</span>";
            section += $"<span style='margin-left: 10px; color: #6c757d; font-family: monospace;'>{asset.CssSelector}</span>";
            section += "</div>";
            
            // Generated Asset IDs
            if (asset.GeneratedAssetIds.Any())
            {
                section += "<div><strong>🏷️ Generated Asset IDs:</strong></div>";
                section += "<div class='asset-ids'>";
                section += string.Join(", ", asset.GeneratedAssetIds);
                section += "</div>";
            }
            
            section += "</div>";
        }
        
        section += "</div>";
        return section;
    }

    /// <summary>
    /// Show error popup using SweetAlert2
    /// </summary>
    private async Task ShowErrorPopup(string title, string message)
    {
        try
        {
            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(5));
            await JSRuntime.InvokeVoidAsync("Swal.fire", cts.Token, new
            {
                title = title,
                text = message,
                icon = "error",
                confirmButtonText = "OK"
            });
        }
        catch (Exception ex)
        {
            // Fallback to console logging if SweetAlert2 fails
            Logger.LogError(ex, "[DEBUG-WORKITEM:popup:FALLBACK] SweetAlert2 popup failed, title: {Title}, message: {Message} ;CLEANUP_OK", title, message);
        }
    }

    /// <summary>
    /// Hub-based fallback method - kept for backward compatibility
    /// </summary>
    private string InjectAssetShareButtonsHubBased(string html)
    {
        Logger.LogWarning("[ASSETSHARE-HUB] Hub-based method called - this should be replaced with database approach");
        return html; // Return original HTML without modification
    }



    /// <summary>
    /// Create HTML for a red share button based on AssetLookup data
    /// </summary>
    private string CreateRedShareButtonHtml(string assetType, string displayName, string shareId, int instanceNumber)
    {
        // HTML-encode all user-provided values to prevent parsing errors
        var encodedAssetType = System.Web.HttpUtility.HtmlEncode(assetType);
        var encodedDisplayName = System.Web.HttpUtility.HtmlEncode(displayName);
        var encodedShareId = System.Web.HttpUtility.HtmlEncode(shareId);
        
        return $@"<div class=""ks-share-wrapper"">" +
               $@"<button class=""ks-share-button ks-share-red"" data-share-button=""asset"" data-share-id=""{encodedShareId}"" data-asset-type=""{encodedAssetType}"" data-instance-number=""{instanceNumber}"" type=""button"" style=""background-color: #dc3545; color: white; border: 1px solid #dc3545; padding: 4px 8px; font-size: 12px; border-radius: 3px; cursor: pointer;"">� SHARE {encodedDisplayName.ToUpper()} #{instanceNumber}</button></div>";
    }

    // CreateShareButtonHtml method moved to AssetProcessingService

    // SanitizeHtml method moved to AssetProcessingService



    // RemoveDeleteButtons method moved to AssetProcessingService

    /// <summary>
    /// KEY FUNCTION 1: Standardized Asset Detection Test Function
    /// Used by all Playwright tests for comprehensive asset detection validation
    /// </summary>
    public async Task<AssetDetectionResult> RunStandardizedAssetDetectionTestAsync(string testIdentifier)
    {
        var runId = $"{testIdentifier}-{DateTime.Now:HHmmss}";
        try
        {
            Logger.LogInformation("[STANDARDIZED-ASSET-DETECTION:{RunId}] Starting detection test ;CLEANUP_OK", runId);
            
            // Load asset lookups from API
            var assetLookups = await AssetProcessor.GetAssetLookupsFromApiAsync(runId);
            if (assetLookups == null || assetLookups.Count == 0)
            {
                Logger.LogError("[STANDARDIZED-ASSET-DETECTION:{RunId}] No asset definitions found ;CLEANUP_OK", runId);
                return new AssetDetectionResult { SourceName = testIdentifier, TotalAssetsDetected = 0 };
            }

            // Get current session transcript
            string currentTranscript = Model?.SessionTranscript ?? "";
            
            // Standard test HTML with canonical Session 212 assets
            var canonicalTestHtml = @"<div class=""ayah-card"" id=""ayah-card-14-34"">
                <div class=""golden-surah-header clickable-ayah-header"" data-ayats=""34"" data-original-token=""Q|14:34"" data-surah=""14"" id=""ayah-header-14-34"">
                    <span>Abraham (14:34)</span>
                </div>
                <p class=""ayah-arabic"">وَإِن تَعُدُّوا نِعْمَتَ اللَّهِ لَا تُحْصُوهَا</p>
                <div class=""translation-header"">Translation:</div>
                <p class=""ayah-translation"">And if you should count the favors of Allah, you could not enumerate them.</p>
            </div>";
            
            // Perform detection analysis
            var testResults = AnalyzeAssetDetection(canonicalTestHtml, assetLookups, testIdentifier);
            var transcriptResults = AnalyzeAssetDetection(currentTranscript, assetLookups, "Live-Session");
            
            // Combined result for test validation
            var combinedResult = new AssetDetectionResult 
            { 
                SourceName = testIdentifier,
                DetectedAssets = testResults.DetectedAssets.Concat(transcriptResults.DetectedAssets).ToList(),
                TotalAssetsDetected = testResults.TotalAssetsDetected + transcriptResults.TotalAssetsDetected
            };
            
            Logger.LogInformation("[STANDARDIZED-ASSET-DETECTION:{RunId}] Detection completed: {Total} assets ;CLEANUP_OK", 
                runId, combinedResult.TotalAssetsDetected);
            
            return combinedResult;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[STANDARDIZED-ASSET-DETECTION:{RunId}] Detection test failed ;CLEANUP_OK", runId);
            return new AssetDetectionResult { SourceName = testIdentifier, TotalAssetsDetected = -1 };
        }
    }

    /// <summary>
    /// KEY FUNCTION 2: Standardized Share Button Injection Test Function  
    /// Used by all Playwright tests for comprehensive injection validation
    /// </summary>
    public async Task<ShareButtonInjectionResult> RunStandardizedShareButtonInjectionTestAsync(string testIdentifier)
    {
        var runId = $"{testIdentifier}-{DateTime.Now:HHmmss}";
        try
        {
            Logger.LogInformation("[STANDARDIZED-SHAREBUTTON-INJECTION:{RunId}] Starting injection test ;CLEANUP_OK", runId);
            
            if (SessionId == null)
            {
                Logger.LogWarning("[STANDARDIZED-SHAREBUTTON-INJECTION:{RunId}] No SessionId available ;CLEANUP_OK", runId);
                return new ShareButtonInjectionResult 
                { 
                    TestIdentifier = testIdentifier, 
                    Success = false, 
                    ErrorMessage = "No SessionId available for injection test" 
                };
            }

            // Load session assets from database
            var sessionAssets = await LoadSessionAssetsAsync(SessionId.Value);
            var assetCount = sessionAssets?.Count ?? 0;
            
            // Test HTML for injection
            var testHtml = @"<div class=""ayah-card"" data-asset-id=""test-ayah-1"">
                <div class=""golden-surah-header"" id=""ayah-header-14-34"">Abraham (14:34)</div>
                <p class=""ayah-arabic"">Test Arabic content</p>
                <p class=""ayah-translation"">Test translation</p>
            </div>";
            
            // Perform injection
            var enhancedHtml = await InjectIndividualShareButtonsAsync(testHtml);
            
            // Analyze injection results
            var buttonCount = CountShareButtons(enhancedHtml);
            var dataAttributeCount = CountDataAssetIds(enhancedHtml);
            
            var result = new ShareButtonInjectionResult
            {
                TestIdentifier = testIdentifier,
                Success = buttonCount > 0 || dataAttributeCount > 0,
                ShareButtonsInjected = buttonCount,
                DataAttributesAdded = dataAttributeCount,
                SessionAssetsAvailable = assetCount,
                EnhancedHtml = enhancedHtml
            };
            
            Logger.LogInformation("[STANDARDIZED-SHAREBUTTON-INJECTION:{RunId}] Injection completed: {Buttons} buttons, {Attributes} attributes ;CLEANUP_OK", 
                runId, buttonCount, dataAttributeCount);
            
            return result;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[STANDARDIZED-SHAREBUTTON-INJECTION:{RunId}] Injection test failed ;CLEANUP_OK", runId);
            return new ShareButtonInjectionResult 
            { 
                TestIdentifier = testIdentifier, 
                Success = false, 
                ErrorMessage = ex.Message 
            };
        }
    }

    /// <summary>
    /// Helper method to count share buttons in HTML
    /// </summary>
    private int CountShareButtons(string html)
    {
        if (string.IsNullOrEmpty(html)) return 0;
        
        var buttonMatches = System.Text.RegularExpressions.Regex.Matches(html, @"class=""[^""]*ks-share-button[^""]*""");
        return buttonMatches.Count;
    }
    
    /// <summary>
    /// Helper method to count data-asset-id attributes in HTML
    /// </summary>
    private int CountDataAssetIds(string html)
    {
        if (string.IsNullOrEmpty(html)) return 0;
        
        var dataMatches = System.Text.RegularExpressions.Regex.Matches(html, @"data-asset-id=""[^""]*""");
        return dataMatches.Count;
    }

    /// <summary>
    /// Adds data-asset-id attributes and SHARE buttons using SessionAssets lookup table
    /// NEW: Uses server-side asset catalog instead of client-side regex parsing
    /// </summary>
    private async Task<string> InjectIndividualShareButtonsAsync(string html)
    {
        try
        {
            Logger.LogInformation("ASSET-INJECTION-V2: Starting SessionAssets-based asset enhancement");
            Logger.LogInformation("ASSET-INJECTION-V2: Input HTML length: {Length}", html.Length);

            if (SessionId == null)
            {
                Logger.LogWarning("ASSET-INJECTION-V2: No SessionId available, skipping asset enhancement");
                return html;
            }

            // NEW: Load pre-detected assets from SessionAssets table
            var sessionAssets = await LoadSessionAssetsAsync(SessionId.Value);
            if (sessionAssets == null || sessionAssets.Count == 0)
            {
                Logger.LogInformation("ASSET-INJECTION-V2: No assets found in lookup table for session {SessionId}", SessionId);
                return html;
            }

            Logger.LogInformation("ASSET-INJECTION-V2: Loaded {Count} assets from lookup table for session {SessionId}",
                sessionAssets.Count, SessionId);

            // Phase 1: Inject data-asset-id attributes into asset containers
            var htmlWithAssetIds = InjectAssetIdentifiers(html, sessionAssets);

            // Phase 2: Add share buttons above identified containers  
            var htmlWithButtons = InjectShareButtons(htmlWithAssetIds, sessionAssets);

            Logger.LogInformation("ASSET-INJECTION-V2: Enhancement complete - HTML length: {Original} → {Final}",
                html.Length, htmlWithButtons.Length);

            return htmlWithButtons;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "ASSET-INJECTION-V2-ERROR: Failed to enhance assets, falling back to original HTML");
            return html; // Graceful degradation
        }
    }

    /// <summary>
    /// Load session assets from the SessionAssets API
    /// </summary>
    private async Task<List<SessionAssetDto>?> LoadSessionAssetsAsync(long sessionId)
    {
        try
        {
            using var httpClient = HttpClientFactory.CreateClient("default");
            var response = await httpClient.GetAsync($"/api/host/sessions/{sessionId}/assets");

            if (!response.IsSuccessStatusCode)
            {
                Logger.LogWarning("ASSET-INJECTION-V2: Failed to load assets from API, status: {StatusCode}", response.StatusCode);
                return new List<SessionAssetDto>();
            }

            var responseContent = await response.Content.ReadAsStringAsync();
            var assetsResponse = System.Text.Json.JsonSerializer.Deserialize<SessionAssetsResponse>(responseContent, new System.Text.Json.JsonSerializerOptions
            {
                PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase
            });

            return assetsResponse?.Assets ?? new List<SessionAssetDto>();
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "ASSET-INJECTION-V2: Exception loading assets from API");
            return new List<SessionAssetDto>();
        }
    }

    /// <summary>
    /// Inject data-asset-id attributes into asset containers for JavaScript targeting
    /// </summary>
    private string InjectAssetIdentifiers(string html, List<SessionAssetDto> assets)
    {
        try
        {
            Logger.LogInformation("ASSET-INJECTION-V2: Injecting data-asset-id attributes for {Count} assets", assets.Count);

            foreach (var asset in assets)
            {
                // Use the asset type patterns to find containers
                if (AssetTypePatterns.TryGetValue(asset.AssetType, out var pattern))
                {
                    var matches = System.Text.RegularExpressions.Regex.Matches(html, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase);

                    // For now, inject into the first match (can be enhanced later for more precise matching)
                    if (matches.Count > 0)
                    {
                        var match = matches[0];
                        var enhancedTag = InjectDataAssetId(match.Value, asset.AssetId);
                        html = html.Replace(match.Value, enhancedTag);

                        Logger.LogDebug("ASSET-INJECTION-V2: Injected data-asset-id='{AssetId}' for {AssetType}",
                            asset.AssetId, asset.AssetType);
                    }
                }
            }

            return html;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "ASSET-INJECTION-V2: Failed to inject asset identifiers");
            return html;
        }
    }

    /// <summary>
    /// Inject SHARE buttons above containers with data-asset-id attributes
    /// </summary>
    private string InjectShareButtons(string html, List<SessionAssetDto> assets)
    {
        try
        {
            Logger.LogInformation("ASSET-INJECTION-V2: Injecting SHARE buttons for {Count} assets", assets.Count);

            // Process in reverse position order to maintain HTML positions during injection
            foreach (var asset in assets.OrderByDescending(a => a.Position ?? int.MaxValue))
            {
                var containerSelector = $"[data-asset-id='{asset.AssetId}']";
                var shareButton = GenerateShareButton(asset.AssetId, asset.AssetType);

                // Find container and inject button before it
                html = InjectButtonBeforeContainer(html, asset.AssetId, shareButton);

                Logger.LogDebug("ASSET-INJECTION-V2: Injected SHARE button for asset {AssetId} ({AssetType})",
                    asset.AssetId, asset.AssetType);
            }

            return html;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "ASSET-INJECTION-V2: Failed to inject share buttons");
            return html;
        }
    }

    /// <summary>
    /// Inject data-asset-id attribute into an HTML opening tag
    /// </summary>
    private string InjectDataAssetId(string openingTag, long assetId)
    {
        var tagEndIndex = openingTag.IndexOf('>');
        if (tagEndIndex == -1) return openingTag;

        var attributeToInsert = $" data-asset-id=\"{assetId}\"";
        return openingTag.Insert(tagEndIndex, attributeToInsert);
    }

    /// <summary>
    /// Inject share button before a container with specified asset ID
    /// </summary>
    private string InjectButtonBeforeContainer(string html, long assetId, string shareButtonHtml)
    {
        try
        {
            var containerPattern = $@"<[^>]*data-asset-id=""{assetId}""[^>]*>";
            var match = System.Text.RegularExpressions.Regex.Match(html, containerPattern);

            if (match.Success)
            {
                html = html.Insert(match.Index, shareButtonHtml);
            }

            return html;
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Failed to inject button for asset {AssetId}", assetId);
            return html;
        }
    }

    /// <summary>
    /// Generate share button HTML for an asset (FIXED: Proper quote escaping for Blazor MarkupString)
    /// </summary>
    private string GenerateShareButton(long assetId, string assetType)
    {
        // ISSUE FIX: Use HTML-encoded quotes and avoid complex inline event handlers that cause parsing errors
        var escapedAssetType = System.Web.HttpUtility.HtmlEncode(assetType);
        
        return $@"<button data-share-button=""asset"" data-asset-id=""{assetId}"" data-asset-type=""{escapedAssetType}"" class=""ks-share-btn"" type=""button"">SHARE</button>";
    }

    // REMOVED: DetectAndTrackAssetsAsync - replaced by simplified database-driven approach

    // REMOVED: InjectAssetShareButtonsAsync - replaced by simplified database-driven approach

    // REMOVED: InjectShareButtonForAsset - replaced by simplified database-driven approach

    // REMOVED: DetectedAsset class - no longer needed with simplified database-driven approach

    // REMOVED: SaveAssetsToDatabase - no longer needed with simplified database-driven approach

    /// <summary>
    /// Asset type patterns for detection (moved from inline to reusable)
    /// </summary>
    private static readonly Dictionary<string, string> AssetTypePatterns = new()
    {
        { "etymology-derivative-card", @"<div[^>]*class=""[^""]*etymology-derivative-card[^""]*""[^>]*>" },
        { "ahadees-container", @"<div[^>]*class=""[^""]*(?:inserted-hadees|ks-ahadees-container|ahadees-content)[^""]*""[^>]*>" },
        { "ayah-card", @"<div[^>]*class=""[^""]*ayah-card[^""]*""[^>]*>" },
        { "image-asset", @"<img[^>]*(?:src=""[^""]*""[^>]*|[^>]*)" },
        { "table-asset", @"<table[^>]*class=""[^""]*(?:islamic-table|content-table|comparison-table)[^""]*""[^>]*>" }
    };

    // Legacy method - keep for fallback
    private string InjectIndividualShareButtons(string html)
    {
        // Call async version and wait
        return InjectIndividualShareButtonsAsync(html).GetAwaiter().GetResult();
    }

    // DTO classes for API responses
    public class SessionAssetDto
    {
        public long AssetId { get; set; }
        public string AssetType { get; set; } = string.Empty;
        public string AssetSelector { get; set; } = string.Empty;
        public int? Position { get; set; }
        public bool IsShared { get; set; }
        public DateTime? SharedAt { get; set; }
    }

    public class SessionAssetsResponse
    {
        public long SessionId { get; set; }
        public int TotalAssets { get; set; }
        public int SharedAssets { get; set; }
        public Dictionary<string, int> AssetsByType { get; set; } = new();
        public List<SessionAssetDto> Assets { get; set; } = new();
        public string? RequestId { get; set; }
    }

    @* [DEBUG-WORKITEM:hostcanvas:continue] Transcript cache removed - using SafeHtmlRenderingService instead ;CLEANUP_OK *@

    @* [DEBUG-WORKITEM:hostcanvas:continue] Obsolete transcript rendering methods removed - using SafeHtmlRenderingService instead ;CLEANUP_OK *@



    private void RenderLargeContentSummary(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder builder, string html)
    {
        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "style", "background:#E0F2FE;border:1px solid #0284C7;border-radius:0.5rem;padding:1.5rem;");
        
        builder.OpenElement(2, "h4");
        builder.AddAttribute(3, "style", "color:#0284C7;margin:0 0 1rem 0;display:flex;align-items:center;gap:0.5rem;");
        builder.OpenElement(4, "i");
        builder.AddAttribute(5, "class", "fa-solid fa-file-text");
        builder.CloseElement();
        builder.AddContent(6, "Large Transcript Content");
        builder.CloseElement();
        
        builder.OpenElement(7, "p");
        builder.AddContent(8, $"This transcript contains {html.Length:N0} characters of content.");
        builder.CloseElement();
        
        builder.OpenElement(9, "p");
        builder.AddContent(10, "To prevent browser performance issues, the full content is not displayed. Use the debug tools below to inspect specific sections if needed.");
        builder.CloseElement();
        
        // Show a safe preview of the first 1000 characters
        var safePreview = html.Substring(0, Math.Min(1000, html.Length));
        var textContent = System.Text.RegularExpressions.Regex.Replace(safePreview, "<[^>]*>", " ");
        textContent = System.Text.RegularExpressions.Regex.Replace(textContent, @"\s+", " ").Trim();
        
        builder.OpenElement(11, "details");
        builder.OpenElement(12, "summary");
        builder.AddAttribute(13, "style", "cursor:pointer;color:#0284C7;font-weight:600;");
        builder.AddContent(14, "Show preview (text only)");
        builder.CloseElement();
        builder.OpenElement(15, "pre");
        builder.AddAttribute(16, "style", "background:#F8FAFC;padding:1rem;border-radius:0.25rem;margin-top:0.5rem;white-space:pre-wrap;font-size:0.875rem;");
        builder.AddContent(17, textContent.Substring(0, Math.Min(500, textContent.Length)) + "...");
        builder.CloseElement();
        builder.CloseElement();
        
        builder.CloseElement();
    }

    private void RenderWithSafeFallback(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder builder, string html)
    {
        try
        {
            // Attempt to clean and render the HTML
            var cleanedHtml = CleanHtmlForSafeRendering(html);
            builder.AddMarkupContent(0, cleanedHtml);
            
            Logger.LogInformation("[DEBUG-WORKITEM:signalcomm:continue] Successfully rendered large content ({Length} chars)", html.Length);
        }
        catch (Exception ex)
        {
            Logger.LogWarning(ex, "[DEBUG-WORKITEM:signalcomm:continue] Safe rendering failed, using text fallback");
            RenderAsPlainText(builder, html);
        }
    }

    private void RenderSanitizedContent(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder builder, string html)
    {
        var sanitizedHtml = SanitizeHtmlForRendering(html);
        builder.AddMarkupContent(0, sanitizedHtml);
        Logger.LogInformation("[DEBUG-WORKITEM:signalcomm:continue] Rendered sanitized content");
    }

    @* [DEBUG-WORKITEM:hostcanvas:continue] Enhanced Processor methods removed - using SafeHtmlRenderingService instead ;CLEANUP_OK *@

    private void RenderErrorFallback(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder builder, Exception ex, int contentLength)
    {
        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "style", "background:#FEF2F2;border:1px solid #EF4444;border-radius:0.5rem;padding:1.5rem;");
        
        builder.OpenElement(2, "h4");
        builder.AddAttribute(3, "style", "color:#EF4444;margin:0 0 1rem 0;display:flex;align-items:center;gap:0.5rem;");
        builder.OpenElement(4, "i");
        builder.AddAttribute(5, "class", "fa-solid fa-exclamation-triangle");
        builder.CloseElement();
        builder.AddContent(6, "Transcript Rendering Error");
        builder.CloseElement();
        
        builder.OpenElement(7, "p");
        builder.AddContent(8, $"Unable to display transcript content ({contentLength:N0} characters).");
        builder.CloseElement();
        
        builder.OpenElement(9, "p");
        builder.AddAttribute(10, "style", "font-family:monospace;font-size:0.875rem;color:#DC2626;");
        builder.AddContent(11, $"Error: {ex.Message}");
        builder.CloseElement();
        
        builder.OpenElement(12, "p");
        builder.AddAttribute(13, "style", "font-size:0.875rem;color:#6B7280;");
        builder.AddContent(14, "This prevents the appendChild JavaScript error while maintaining functionality. The content is still available through the API endpoints.");
        builder.CloseElement();
        
        builder.CloseElement();
    }

    private void RenderAsPlainText(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder builder, string html)
    {
        // Extract text content only, removing all HTML tags
        var textContent = System.Text.RegularExpressions.Regex.Replace(html, "<[^>]*>", "\n");
        textContent = System.Text.RegularExpressions.Regex.Replace(textContent, @"\n\s*\n", "\n\n");
        textContent = System.Web.HttpUtility.HtmlDecode(textContent).Trim();
        
        builder.OpenElement(0, "div");
        builder.AddAttribute(1, "style", "background:#F9FAFB;border:1px solid #D1D5DB;border-radius:0.5rem;padding:1.5rem;");
        
        builder.OpenElement(2, "div");
        builder.AddAttribute(3, "style", "display:flex;align-items:center;gap:0.5rem;margin-bottom:1rem;color:#6B7280;");
        builder.OpenElement(4, "i");
        builder.AddAttribute(5, "class", "fa-solid fa-file-text");
        builder.CloseElement();
        builder.AddContent(6, "Transcript (Text Only)");
        builder.CloseElement();
        
        builder.OpenElement(7, "pre");
        builder.AddAttribute(8, "style", "white-space:pre-wrap;font-family:system-ui;line-height:1.6;margin:0;");
        builder.AddContent(9, textContent);
        builder.CloseElement();
        
        builder.CloseElement();
    }

    private bool ContainsPotentiallyProblematicContent(string html)
    {
        if (string.IsNullOrEmpty(html)) return false;
        
        // Check for patterns that commonly cause appendChild errors
        var problematicPatterns = new[]
        {
            @"<[^>]*[""'][^""']*[\u0000-\u001F]", // Control characters in attributes
            @"<script[^>]*>.*?</script>", // Script tags
            @"javascript:", // JavaScript URLs
            @"on\w+\s*=", // Event handlers
            @"<iframe", // Iframes
            @"<object", // Object elements
            @"<embed", // Embed elements
            @"<form", // Forms (can cause issues)
            @"<%.*?%>", // ASP/JSP tags
            @"<\?.*?\?>", // PHP tags
        };
        
        foreach (var pattern in problematicPatterns)
        {
            if (System.Text.RegularExpressions.Regex.IsMatch(html, pattern, System.Text.RegularExpressions.RegexOptions.IgnoreCase))
            {
                return true;
            }
        }
        
        return false;
    }

    private string CleanHtmlForSafeRendering(string html)
    {
        if (string.IsNullOrEmpty(html)) return string.Empty;
        
        // Remove potentially problematic elements and attributes
        var cleaned = html;
        
        // Remove script tags completely
        cleaned = System.Text.RegularExpressions.Regex.Replace(cleaned, @"<script[^>]*>.*?</script>", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase | System.Text.RegularExpressions.RegexOptions.Singleline);
        
        // Remove event handlers
        cleaned = System.Text.RegularExpressions.Regex.Replace(cleaned, @"\s+on\w+\s*=\s*[""'][^""']*[""']", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
        
        // Remove javascript: URLs
        cleaned = System.Text.RegularExpressions.Regex.Replace(cleaned, @"javascript:[^""'\s>]*", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
        
        // Remove any control characters that might cause parsing issues
        cleaned = System.Text.RegularExpressions.Regex.Replace(cleaned, @"[\u0000-\u001F\u007F-\u009F]", "");
        
        return cleaned;
    }

    private string SanitizeHtmlForRendering(string html)
    {
        // More aggressive sanitization for problematic content
        var sanitized = CleanHtmlForSafeRendering(html);
        
        // Ensure all tags are properly closed
        sanitized = EnsureTagsClosed(sanitized);
        
        return sanitized;
    }

    private string EnsureTagsClosed(string html)
    {
        // Simple approach: wrap in a container div to ensure valid structure
        if (!html.Trim().StartsWith("<div") || !html.Trim().EndsWith("</div>"))
        {
            return $"<div class=\"transcript-content\">{html}</div>";
        }
        return html;
    }
    
    // Debug Actions Factory
    private List<NoorCanvas.Models.Debug.IDebugAction> GetHostControlPanelDebugActions()
    {
        var actions = new List<NoorCanvas.Models.Debug.IDebugAction>();
        
        // Test Share Asset Action
        actions.Add(new NoorCanvas.Models.Debug.DebugAction(
            "Test Share Asset",
            "Test SignalR asset sharing functionality",
            async () => await TestShareAsset(),
            "fa-solid fa-share"
        )
        {
            IsEnabled = Model?.SessionStatus == "Active" && SessionId.HasValue && !isLoading
        });
        
        // Test Asset Detection Action
        actions.Add(new NoorCanvas.Models.Debug.DebugAction(
            "Test Asset Detection",
            "Test asset detection in transcript content",
            async () => await TestAssetDetectionAsync(),
            "fa-solid fa-search"
        )
        {
            IsEnabled = !isLoading
        });
        
        return actions;
    }
    
    // Phase 4: Format session description to proper case
    private string FormatSessionDescriptionToProperCase(string description)
    {
        if (string.IsNullOrWhiteSpace(description))
            return description ?? "";
            
        // Convert to proper case (capitalize first letter of each word)
        var words = description.Split(' ', StringSplitOptions.RemoveEmptyEntries);
        var properCaseWords = new List<string>();
        
        foreach (var word in words)
        {
            if (word.Length == 0) continue;
            
            // Handle common articles and prepositions that should remain lowercase
            // except when they're the first word
            var lowercaseWords = new[] { "a", "an", "the", "and", "or", "but", "in", "on", "at", "to", "for", "of", "with", "by", "from", "up", "about", "into", "through", "during", "before", "after", "above", "below", "over", "under", "between", "among" };
            
            if (properCaseWords.Count > 0 && lowercaseWords.Contains(word.ToLower()))
            {
                properCaseWords.Add(word.ToLower());
            }
            else
            {
                // Capitalize first letter, keep rest as original case
                properCaseWords.Add(char.ToUpper(word[0]) + word.Substring(1).ToLower());
            }
        }
        
        return string.Join(" ", properCaseWords);
    }
    
    // Format duration from string value (e.g., "60") to display format (e.g., "1 hour")
    private static string FormatDurationFromString(string? durationString)
    {
        if (string.IsNullOrEmpty(durationString)) return "TBD";
        
        if (int.TryParse(durationString, out int minutes))
        {
            if (minutes >= 60)
            {
                var hours = minutes / 60;
                var remainingMinutes = minutes % 60;
                
                if (remainingMinutes > 0)
                    return $"{hours}h {remainingMinutes}m";
                else
                    return $"{hours} hour{(hours > 1 ? "s" : "")}";
            }
            else
            {
                return $"{minutes} min{(minutes > 1 ? "s" : "")}";
            }
        }
        
        return durationString; // Return as-is if not parseable
    }
    
    // Copy User Landing Link - Simplified for reliability
    private async Task CopyUserLink()
    {
        try
        {
            if (!string.IsNullOrEmpty(UserToken) && Model != null)
            {
                var userLink = $"https://localhost:9091/user/landing/{UserToken}";
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", userLink);
                Model.UserCopied = true;
                StateHasChanged();
                
                await Task.Delay(3000);
                Model.UserCopied = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying user URL to clipboard");
        }
    }

    // Handle user link click - copy to clipboard and allow link to open in new window
    private async Task HandleUserLinkClick()
    {
        try
        {
            if (!string.IsNullOrEmpty(UserToken) && Model != null)
            {
                var userLink = $"https://localhost:9091/user/landing/{UserToken}";
                await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", userLink);
                
                // Brief visual feedback that copy occurred
                Model.UserCopied = true;
                StateHasChanged();
                
                // Reset copy indicator after a short delay
                await Task.Delay(1500);
                Model.UserCopied = false;
                StateHasChanged();
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "Error copying user URL to clipboard when clicking link");
        }
    }

    private string GetCopyButtonStyle()
    {
        var baseStyle = "padding:0.375rem 0.75rem;border:none;border-radius:0.375rem;font-size:0.75rem;cursor:pointer;transition:all 0.3s ease;font-family:'Inter',sans-serif;font-weight:500;display:flex;align-items:center;gap:0.25rem;";
        
        if (Model?.UserCopied == true)
        {
            return baseStyle + "background-color:#10b981;color:#ffffff;";
        }
        
        return baseStyle + "background-color:#3B82F6;color:#ffffff;";
    }

    private string GetCopyIcon()
    {
        return Model?.UserCopied == true ? "fa-solid fa-check" : "fa-solid fa-copy";
    }

    private string GetCopyText()
    {
        return Model?.UserCopied == true ? "Copied!" : "Copy";
    }
    
    /// <summary>
    /// Get AssetLookup definitions from API instead of direct database access
    /// </summary>
    // GetAssetLookupsFromApiAsync method moved to AssetProcessingService
    
    // AssetLookup models moved to AssetProcessingService

    /// <summary>
    /// [DEBUG-WORKITEM:api:impl:09291900-api] Get session details from KSESSIONS API instead of direct database access
    /// </summary>
    private async Task<SessionDetailsDto?> GetSessionDetailsFromApiAsync(long sessionId, string runId)
    {
        try
        {
            Logger.LogInformation("[DEBUG-WORKITEM:api:impl:{RunId}] [SESSION-DETAILS-API] Calling KSESSIONS session details API for sessionId: {SessionId} ;CLEANUP_OK", runId, sessionId);
            
            using var httpClient = HttpClientFactory.CreateClient("default");
            var response = await httpClient.GetAsync($"/api/host/ksessions/session/{sessionId}/details?hostToken={HostToken}");
            
            if (!response.IsSuccessStatusCode)
            {
                Logger.LogError("[DEBUG-WORKITEM:api:impl:{RunId}] [SESSION-DETAILS-API] API call failed with status: {StatusCode} ;CLEANUP_OK", runId, response.StatusCode);
                return null;
            }
            
            var apiResponse = await response.Content.ReadFromJsonAsync<EnhancedSessionDetailsApiResponse>();
            
            if (apiResponse?.Success == true && apiResponse.Session != null)
            {
                Logger.LogInformation("[DEBUG-WORKITEM:api:impl:{RunId}] [SESSION-DETAILS-API] Successfully retrieved session details from API - SessionName: {SessionName}, TranscriptLength: {TranscriptLength} ;CLEANUP_OK", 
                    runId, apiResponse.Session.SessionName, apiResponse.Session.Transcript?.Length ?? 0);
                
                return apiResponse.Session;
            }
            else
            {
                Logger.LogWarning("[DEBUG-WORKITEM:api:impl:{RunId}] [SESSION-DETAILS-API] API response was null or unsuccessful - Message: {Message} ;CLEANUP_OK", runId, apiResponse?.Message);
                return null;
            }
        }
        catch (Exception ex)
        {
            Logger.LogError(ex, "[DEBUG-WORKITEM:api:impl:{RunId}] [SESSION-DETAILS-API] Exception calling session details API for sessionId: {SessionId} ;CLEANUP_OK", runId, sessionId);
            return null;
        }
    }

    // Session Details API models for Blazor client
    public class SessionDetailsDto
    {
        public int SessionId { get; set; }
        public int GroupId { get; set; }
        public int CategoryId { get; set; }
        public string SessionName { get; set; } = string.Empty;
        public string? Description { get; set; }
        public DateTime? SessionDate { get; set; }
        public string? MediaPath { get; set; }
        public int? SpeakerId { get; set; }
        public bool? IsActive { get; set; }
        public string? Transcript { get; set; }
        public DateTime? CreatedDate { get; set; }
        public DateTime? ChangedDate { get; set; }
        public string? GroupName { get; set; }
        public string? CategoryName { get; set; }
        public string? SpeakerName { get; set; }
    }

    public class EnhancedSessionDetailsApiResponse
    {
        public bool Success { get; set; }
        public string? Message { get; set; }
        public SessionDetailsDto? Session { get; set; }
        public int TotalCount { get; set; }
    }

    /// <summary>
    /// DTO for AssetLookup data from API
    /// </summary>
    public class AssetLookupDto
    {
        public string AssetIdentifier { get; set; } = "";
        public string? CssSelector { get; set; }
        public string? DisplayName { get; set; }
        public bool IsActive { get; set; }
    }

    /// <summary>
    /// Asset detection analysis result for a specific content source
    /// </summary>
    public class AssetDetectionResult
    {
        public string SourceName { get; set; } = "";
        public List<DetectedAsset> DetectedAssets { get; set; } = new();
        public int TotalAssetsDetected { get; set; }
    }

    /// <summary>
    /// Information about a detected asset
    /// </summary>
    public class DetectedAsset
    {
        public int AssetId { get; set; }
        public string Name { get; set; } = "";
        public string CssSelector { get; set; } = "";
        public int Count { get; set; }
        public string Description { get; set; } = "";
        public List<string> GeneratedAssetIds { get; set; } = new();
    }

    /// <summary>
    /// Result of share button injection test
    /// </summary>
    public class ShareButtonInjectionResult
    {
        public string TestIdentifier { get; set; } = "";
        public bool Success { get; set; }
        public int ShareButtonsInjected { get; set; }
        public int DataAttributesAdded { get; set; }
        public int SessionAssetsAvailable { get; set; }
        public string EnhancedHtml { get; set; } = "";
        public string ErrorMessage { get; set; } = "";
    }
}

<script>


    // Individual Asset Sharing Function (called by auto-injected SHARE buttons)
    window.shareIndividualAsset = async function(assetId, assetType) {
        console.log('NOOR-ASSET-SHARE: Sharing individual asset:', assetId, 'Type:', assetType);
        
        try {
            // Get session details (safely encoded using System.Text.Json)
            const sessionId = @(System.Text.Json.JsonSerializer.Serialize(SessionId ?? 0));
            const hostToken = @(System.Text.Json.JsonSerializer.Serialize(HostToken ?? ""));
            
            if (!sessionId || !hostToken) {
                console.error('NOOR-ASSET-SHARE: Missing session ID or host token');
                alert('Session information not available. Please refresh the page.');
                return;
            }

            // Find the asset element
            const assetElement = document.querySelector(`[data-asset-id="${assetId}"]`);
            if (!assetElement) {
                console.error('NOOR-ASSET-SHARE: Asset element not found:', assetId);
                return;
            }

            // Find the SHARE button
            const shareButton = document.querySelector(`button[data-asset-id="${assetId}"]`);
            if (!shareButton) {
                console.error('NOOR-ASSET-SHARE: Share button not found for asset:', assetId);
                return;
            }

            // Visual feedback - button state
            const originalText = shareButton.textContent;
            const originalBg = shareButton.style.backgroundColor;
            shareButton.textContent = 'SHARING...';
            shareButton.style.backgroundColor = '#f59e0b';
            shareButton.disabled = true;

            // Call share API
            const shareResponse = await fetch('/api/host/share-asset', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    sessionId: parseInt(sessionId),
                    content: assetElement.outerHTML,
                    assetType: assetType,
                    assetId: assetId,
                    metadata: {
                        textContent: assetElement.textContent?.substring(0, 100) || '',
                        className: assetElement.className || '',
                        sharedAt: new Date().toISOString()
                    }
                })
            });

            if (shareResponse.ok) {
                const result = await shareResponse.json();
                console.log('NOOR-ASSET-SHARE: Asset shared successfully:', result);
                
                // TOASTR: Show API success notification
                if (typeof window.showNoorToast === 'function') {
                    window.showNoorToast(
                        `${assetType} successfully shared with all participants!`, 
                        '✅ Share Complete', 
                        'success'
                    );
                    console.log('[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: API success notification shown for:', assetId);
                }
                
                // Success feedback
                shareButton.textContent = '✓ SHARED';
                shareButton.style.backgroundColor = '#059669';
                
                setTimeout(() => {
                    shareButton.textContent = originalText;
                    shareButton.style.backgroundColor = originalBg;
                    shareButton.disabled = false;
                }, 3000);
                
            } else {
                throw new Error(`Share API returned ${shareResponse.status}`);
            }

        } catch (error) {
            console.error('NOOR-ASSET-SHARE: Error sharing asset:', assetId, error);
            
            // Show detailed error message to user
            let errorMessage = 'Unknown error occurred';
            if (error.message) {
                errorMessage = error.message;
            } else if (typeof error === 'string') {
                errorMessage = error;
            }
            
            // TOASTR: Show asset sharing error  
            if (typeof window.showNoorToast === 'function') {
                window.showNoorToast(
                    `Failed to share ${assetType}: ${errorMessage}`, 
                    'Share Failed', 
                    'error'
                );
                console.log('[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: Asset sharing error shown:', errorMessage);
            } else {
                // Fallback to existing error toast function
                showErrorToast(`Failed to share asset: ${errorMessage}`);
            }
            
            // Find button and show error feedback
            const shareButton = document.querySelector(`button[data-asset-id="${assetId}"]`);
            if (shareButton) {
                shareButton.textContent = '✗ ERROR';
                shareButton.style.backgroundColor = '#dc2626';
                shareButton.title = `Error: ${errorMessage}`;
                
                setTimeout(() => {
                    shareButton.textContent = 'SHARE';
                    shareButton.style.backgroundColor = '#dc2626';
                    shareButton.disabled = false;
                    shareButton.title = 'Share this asset';
                }, 3000);
            }
        }
    };

    // SignalR Asset Sharing Function (called by injected share buttons) - updated for individual assets
    window.shareAssetViaSignalR = async function(shareId, assetType, instanceCount, uniqueAssetId) {
        try {
            console.log('NOOR-ASSET-SIGNALR: Sharing individual asset via SignalR', { 
                shareId, assetType, instanceCount, uniqueAssetId 
            });
            
            if (window.signalRConnection && window.signalRConnection.state === 'Connected') {
                // Send individual asset share via SignalR hub with unique identifier
                const assetData = {
                    shareId: shareId,
                    assetType: assetType,
                    uniqueAssetId: uniqueAssetId,
                    instanceCount: 1 // Always 1 for individual assets
                };
                
                await window.signalRConnection.invoke('ShareAsset', window.currentSessionId, assetData);
                console.log('NOOR-ASSET-SIGNALR: Individual asset shared successfully via SignalR hub');
                
                // TOASTR: Show SignalR success notification
                if (typeof window.showNoorToast === 'function') {
                    window.showNoorToast(
                        `${assetType} #${instanceCount} shared via SignalR successfully!`, 
                        '✅ SignalR Share Complete', 
                        'success'
                    );
                    console.log('[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: SignalR success notification shown');
                }
                
                // Show success feedback
                const button = document.querySelector(`[data-share-id="${shareId}"]`);
                if (button) {
                    const originalText = button.textContent;
                    button.textContent = '✅ SHARED VIA SIGNALR!';
                    button.style.backgroundColor = '#16a34a';
                    button.disabled = true;
                    
                    // Restore button after 3 seconds
                    setTimeout(() => {
                        button.textContent = originalText;
                        button.style.backgroundColor = '#dc2626';
                        button.disabled = false;
                    }, 3000);
                }
            } else {
                console.error('NOOR-ASSET-SIGNALR: SignalR connection not available or not connected');
                
                // TOASTR: Show SignalR connection error
                if (typeof window.showNoorToast === 'function') {
                    window.showNoorToast(
                        'SignalR connection is not available. Please refresh the page and try again.', 
                        'Connection Error', 
                        'error'
                    );
                    console.log('[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: SignalR connection error shown');
                } else {
                    alert('SignalR connection is not available. Please refresh the page and try again.');
                }
            }
        } catch (error) {
            console.error('NOOR-ASSET-SIGNALR: Error sharing individual asset via SignalR:', error);
            
            // TOASTR: Show SignalR exception error
            if (typeof window.showNoorToast === 'function') {
                window.showNoorToast(
                    `Failed to share ${assetType} via SignalR: ${error.message}`, 
                    'SignalR Error', 
                    'error'
                );
                console.log('[DEBUG-WORKITEM:sharebutton-toastr] 📢 TOASTR: SignalR exception error shown:', error.message);
            } else {
                alert('Failed to share individual asset via SignalR: ' + error.message);
            }
        }
    };

    console.log('NOOR-ASSET-SHARE: Individual asset sharing system ready with SignalR support');

    // Toast Notification Functions for Q&A Alerts
    window.showQuestionToast = function(questionText) {
        // Create toast element
        const toast = document.createElement('div');
        toast.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <i class="fa-solid fa-question-circle" style="color: #3B82F6; font-size: 1.2rem;"></i>
                <div>
                    <div style="font-weight: 600; margin-bottom: 0.25rem;">New Question Received!</div>
                    <div style="font-size: 0.875rem; opacity: 0.9; max-width: 300px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${questionText}
                    </div>
                </div>
            </div>
        `;
        toast.style.cssText = `
            position: fixed; 
            top: 1rem; 
            right: 1rem; 
            background-color: #3B82F6; 
            color: white; 
            padding: 1rem 1.5rem; 
            border-radius: 0.75rem; 
            box-shadow: 0 10px 25px -5px rgba(59, 130, 246, 0.4); 
            z-index: 9999; 
            opacity: 0; 
            transform: translateX(100%); 
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
            max-width: 400px;
        `;
        
        document.body.appendChild(toast);
        
        // Show toast
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(0)';
        }, 100);
        
        // Hide toast after 4 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 4000);
    };

    window.showVoteUpdateToast = function(questionText, voteCount) {
        // Create toast element
        const toast = document.createElement('div');
        toast.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <i class="fa-solid fa-thumbs-up" style="color: #10B981; font-size: 1.2rem;"></i>
                <div>
                    <div style="font-weight: 600; margin-bottom: 0.25rem;">Question Voted! (${voteCount} votes)</div>
                    <div style="font-size: 0.875rem; opacity: 0.9; max-width: 280px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                        ${questionText}
                    </div>
                </div>
            </div>
        `;
        toast.style.cssText = `
            position: fixed; 
            top: 1rem; 
            right: 1rem; 
            background-color: #10B981; 
            color: white; 
            padding: 1rem 1.5rem; 
            border-radius: 0.75rem; 
            box-shadow: 0 10px 25px -5px rgba(16, 185, 129, 0.4); 
            z-index: 9999; 
            opacity: 0; 
            transform: translateX(100%); 
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
            max-width: 400px;
        `;
        
        document.body.appendChild(toast);
        
        // Show toast
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(0)';
        }, 100);
        
        // Hide toast after 3 seconds
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 3000);
    };

    window.showErrorToast = function(errorMessage) {
        // Create error toast element
        const toast = document.createElement('div');
        toast.innerHTML = `
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span style="font-size: 1.2em;">⚠️</span>
                <div>
                    <div style="font-weight: 600; margin-bottom: 0.25rem;">Asset Sharing Error</div>
                    <div style="font-size: 0.9em; opacity: 0.9;">
                        ${errorMessage}
                    </div>
                </div>
            </div>
        `;
        toast.style.cssText = `
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: linear-gradient(135deg, #DC2626, #B91C1C);
            color: white;
            padding: 1rem 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(220, 38, 38, 0.4);
            transform: translateX(100%);
            transition: transform 0.3s ease;
            z-index: 10000;
            font-family: 'Inter', sans-serif;
            min-width: 350px;
            max-width: 500px;
        `;
        
        document.body.appendChild(toast);
        
        // Show toast
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(0)';
        }, 100);
        
        // Hide toast after 5 seconds (longer for errors)
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => document.body.removeChild(toast), 300);
        }, 5000);
    };

    // Debug Share Toast Function - shows comprehensive debugging info
    window.showShareDebugToast = function(message, data, type = 'info') {
        const colors = {
            info: { bg: '#3B82F6', icon: '🔍' },
            success: { bg: '#10B981', icon: '✅' },
            error: { bg: '#DC2626', icon: '❌' },
            warning: { bg: '#F59E0B', icon: '⚠️' },
            payload: { bg: '#8B5CF6', icon: '📦' }
        };
        
        const config = colors[type] || colors.info;
        
        const toast = document.createElement('div');
        toast.innerHTML = `
            <div style="display: flex; align-items: flex-start; gap: 0.75rem;">
                <span style="font-size: 1.5rem;">${config.icon}</span>
                <div style="flex: 1;">
                    <div style="font-weight: 600; margin-bottom: 0.5rem; font-size: 1rem;">${message}</div>
                    ${data ? `<pre style="background: rgba(0,0,0,0.2); padding: 0.5rem; border-radius: 0.5rem; font-size: 0.75rem; max-height: 200px; overflow-y: auto; margin: 0; white-space: pre-wrap; word-break: break-all;">${typeof data === 'object' ? JSON.stringify(data, null, 2) : data}</pre>` : ''}
                </div>
            </div>
        `;
        
        toast.style.cssText = `
            position: fixed;
            top: 1rem;
            right: 1rem;
            background: ${config.bg};
            color: white;
            padding: 1rem;
            border-radius: 0.75rem;
            box-shadow: 0 10px 25px rgba(0,0,0,0.3);
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            z-index: 10001;
            font-family: 'Consolas', 'Monaco', monospace;
            max-width: 500px;
            word-wrap: break-word;
        `;
        
        document.body.appendChild(toast);
        
        // Show toast
        setTimeout(() => {
            toast.style.opacity = '1';
            toast.style.transform = 'translateX(0)';
        }, 100);
        
        // Auto-hide after 8 seconds for debug messages
        setTimeout(() => {
            toast.style.opacity = '0';
            toast.style.transform = 'translateX(100%)';
            setTimeout(() => {
                if (document.body.contains(toast)) {
                    document.body.removeChild(toast);
                }
            }, 300);
        }, 8000);
    };

    // Simplified clipboard handling - Blazor will handle copy operations directly via JSRuntime

    // Copy User Landing Link Function (Legacy - keeping for compatibility)
    window.copyUserLink = function() {
        const input = document.getElementById('userLinkInput');
        if (input) {
            input.select();
            input.setSelectionRange(0, 99999); // For mobile devices

            // Try using modern clipboard API first
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(input.value).then(() => {
                    console.log('NOOR-HOST-PANEL: User link copied to clipboard');
                    showCopyFeedback();
                }).catch(err => {
                    console.error('NOOR-HOST-PANEL: Failed to copy with clipboard API:', err);
                    // Fallback to execCommand
                    document.execCommand('copy');
                    showCopyFeedback();
                });
            } else {
                // Fallback for older browsers
                document.execCommand('copy');
                showCopyFeedback();
            }
        }
    };

    // Copy functionality is now handled entirely by Blazor via JSRuntime - no JavaScript manipulation needed

    // Error Display Panel Functions
    let currentError = null;

    function showErrorPanel(error, details = null) {
        console.log('[DEBUG-WORKITEM:hostcanvas:ui] Showing error panel:', error);
        
        currentError = {
            message: error.toString(),
            details: details || error.stack || 'No additional details available',
            timestamp: new Date().toISOString()
        };

        const panel = document.getElementById('noor-error-panel');
        const messageEl = document.getElementById('error-message');
        const timestampEl = document.getElementById('error-timestamp');
        const stackEl = document.getElementById('error-stack');

        if (panel && messageEl && timestampEl && stackEl) {
            messageEl.textContent = currentError.message;
            timestampEl.textContent = new Date(currentError.timestamp).toLocaleString();
            stackEl.textContent = currentError.details;
            panel.style.display = 'block';
            
            // Scroll to top to make error visible
            panel.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }

    function dismissError() {
        const panel = document.getElementById('noor-error-panel');
        if (panel) {
            panel.style.display = 'none';
        }
        currentError = null;
    }

    function toggleErrorDetails() {
        const details = document.getElementById('error-details');
        if (details) {
            details.style.display = details.style.display === 'none' ? 'block' : 'none';
        }
    }

    async function copyErrorToClipboard() {
        if (!currentError) return;
        
        const errorReport = `NOOR Canvas Error Report
Generated: ${currentError.timestamp}
Host Control Panel - Asset Sharing Error

Error Message:
${currentError.message}

Technical Details:
${currentError.details}

Page URL: ${window.location.href}
User Agent: ${navigator.userAgent}
Timestamp: ${new Date().toISOString()}

Please share this report with the development team for debugging.`;

        try {
            await navigator.clipboard.writeText(errorReport);
            
            const button = document.getElementById('copy-error-btn');
            if (button) {
                const originalContent = button.innerHTML;
                button.innerHTML = '<i class="fa-solid fa-check"></i> <span>Copied!</span>';
                button.style.backgroundColor = '#059669';
                
                setTimeout(() => {
                    button.innerHTML = originalContent;
                    button.style.backgroundColor = '#DC2626';
                }, 2000);
            }
        } catch (err) {
            console.error('Failed to copy error report:', err);
            // Fallback: show in a modal/alert
            alert('Copy failed. Please manually copy:\n\n' + errorReport);
        }
    }

    // Global error handler to catch unhandled errors
    window.addEventListener('error', function(event) {
        console.error('[DEBUG-WORKITEM:hostcanvas:error] Global error caught:', event.error);
        showErrorPanel(event.error || event.message, event.error?.stack);
    });

    // Promise rejection handler
    window.addEventListener('unhandledrejection', function(event) {
        console.error('[DEBUG-WORKITEM:hostcanvas:error] Unhandled promise rejection:', event.reason);
        showErrorPanel(event.reason, event.reason?.stack);
    });

    // Override console.error to capture application errors
    const originalConsoleError = console.error;
    console.error = function(...args) {
        originalConsoleError.apply(console, args);
        
        // Show error panel for specific error patterns
        const errorMessage = args.join(' ');
        if (errorMessage.includes('NOOR-') || errorMessage.includes('ShareAsset') || errorMessage.includes('SignalR')) {
            showErrorPanel(errorMessage, 'Console error captured by error display system');
        }
    };

    console.log('[DEBUG-WORKITEM:hostcanvas:ui] Error display system initialized');
    
    // [DEBUG-WORKITEM:assetshare:continue] Share button handler setup ;CLEANUP_OK
    function setupShareButtonHandlers(dotNetObjectRef) {
        const handlerSetupTime = new Date();
        const timeString = handlerSetupTime.toLocaleTimeString() + '.' + handlerSetupTime.getMilliseconds().toString().padStart(3, '0');
        
        console.log('[DEBUG-WORKITEM:assetshare:continue] 🚀 Setting up share button handlers...');
        console.log('[ASSET-SHARE-TIMING] 👂 HANDLER SETUP START:', timeString);
        console.log('[DEBUG-WORKITEM:assetshare:continue] 🔍 DotNet reference received:', dotNetObjectRef);
        
        // Remove existing listeners to prevent duplicates
        document.removeEventListener('click', handleShareButtonClick);
        console.log('[DEBUG-WORKITEM:assetshare:continue] 🗑️  Removed existing click listener');
        
        // Store reference for cleanup
        window.dotNetRef = dotNetObjectRef;
        console.log('[DEBUG-WORKITEM:assetshare:continue] 💾 Stored DotNet reference to window.dotNetRef');
        
        // Check for existing share buttons
        const existingButtons = document.querySelectorAll('.ks-share-button');
        console.log('[DEBUG-WORKITEM:assetshare:continue] 🔍 Found existing share buttons:', {
            count: existingButtons.length,
            buttons: Array.from(existingButtons).map(btn => ({
                shareId: btn.getAttribute('data-share-id'),
                assetType: btn.getAttribute('data-asset-type'),
                innerHTML: btn.innerHTML.substring(0, 50)
            }))
        });
        
        // Add event listener for share button clicks using event delegation
        document.addEventListener('click', handleShareButtonClick);
        console.log('[DEBUG-WORKITEM:assetshare:continue] 👂 Added new click event listener');
        
        const handlerCompleteTime = new Date();
        const completeTimeString = handlerCompleteTime.toLocaleTimeString() + '.' + handlerCompleteTime.getMilliseconds().toString().padStart(3, '0');
        console.log('[ASSET-SHARE-TIMING] ✅ HANDLER SETUP COMPLETE:', completeTimeString);
        console.log('[ASSET-SHARE-TIMING] ⏱️ SETUP DURATION:', (handlerCompleteTime - handlerSetupTime) + 'ms');
        
        // Test click handler by simulating a click
        if (existingButtons.length > 0) {
            console.log('[DEBUG-WORKITEM:assetshare:continue] 🧪 Testing click handler with first button...');
            // Don't actually click, just log that we could
            const firstButton = existingButtons[0];
            console.log('[DEBUG-WORKITEM:assetshare:continue] 🎯 First button details:', {
                tagName: firstButton.tagName,
                className: firstButton.className,
                attributes: Array.from(firstButton.attributes).map(attr => `${attr.name}="${attr.value}"`).join(', ')
            });
        }
        
        console.log('[DEBUG-WORKITEM:assetshare:continue] ✅ Share button handlers setup completed successfully!');
    }
    
    function handleShareButtonClick(event) {
        // [DEBUG-WORKITEM:assetshare:continue] Enhanced click debugging - log ALL clicks first
        const clickData = {
            target: event.target,
            tagName: event.target.tagName,
            className: event.target.className,
            hasClosest: !!event.target.closest,
            allClasses: Array.from(event.target.classList || [])
        };
        
        console.log('[DEBUG-WORKITEM:assetshare:continue] 🔍 CLICK DETECTED:', clickData);
        
        // TOAST: Show click detection
        showShareDebugToast('🔍 CLICK DETECTED!', clickData, 'info');
        
        // Check if clicked element is a share button
        const shareButton = event.target.closest('.ks-share-button');
        
        const shareButtonCheck = {
            foundShareButton: !!shareButton,
            shareButtonElement: shareButton,
            shareButtonClasses: shareButton ? Array.from(shareButton.classList) : null
        };
        
        console.log('[DEBUG-WORKITEM:assetshare:continue] 🔍 SHARE BUTTON CHECK:', shareButtonCheck);
        
        // TOAST: Show share button detection result
        if (shareButton) {
            showShareDebugToast('✅ SHARE BUTTON FOUND!', shareButtonCheck, 'success');
        } else {
            showShareDebugToast('❌ Not a share button click', shareButtonCheck, 'warning');
        }
        
        if (!shareButton) {
            console.log('[DEBUG-WORKITEM:assetshare:continue] ❌ Not a share button click, ignoring');
            return;
        }
        
        event.preventDefault();
        
        const shareId = shareButton.getAttribute('data-share-id');
        const assetType = shareButton.getAttribute('data-asset-type');
        const instanceNumber = parseInt(shareButton.getAttribute('data-instance-number')) || 1;
        
        const attributesData = {
            shareId,
            assetType,
            instanceNumber,
            allAttributes: Array.from(shareButton.attributes).map(attr => ({
                name: attr.name,
                value: attr.value
            }))
        };
        
        console.log('[DEBUG-WORKITEM:assetshare:continue] 🔍 SHARE BUTTON ATTRIBUTES:', attributesData);
        
        // TOAST: Show extracted attributes
        showShareDebugToast('📋 SHARE BUTTON ATTRIBUTES', attributesData, 'info');
        
        if (!shareId || !assetType) {
            const errorData = { shareId, assetType, instanceNumber };
            console.error('[DEBUG-WORKITEM:assetshare:continue] ❌ Missing data attributes:', errorData);
            showShareDebugToast('❌ MISSING DATA ATTRIBUTES', errorData, 'error');
            alert(`Missing data attributes: shareId=${shareId}, assetType=${assetType}`);
            return;
        }
        
        // Find and display the HTML payload that would be shared
        const assetElement = document.querySelector(`[data-asset-id="${shareId}"]`);
        if (assetElement) {
            const htmlPayload = {
                outerHTML: assetElement.outerHTML.substring(0, 500) + (assetElement.outerHTML.length > 500 ? '...' : ''),
                textContent: assetElement.textContent?.substring(0, 200) || '',
                className: assetElement.className || '',
                elementFound: true
            };
            showShareDebugToast('📦 HTML PAYLOAD TO BE SHARED', htmlPayload, 'payload');
        } else {
            showShareDebugToast('❌ ASSET ELEMENT NOT FOUND', { shareId, selector: `[data-asset-id="${shareId}"]` }, 'error');
        }
        
        console.log('[DEBUG-WORKITEM:assetshare:continue] ✅ Share button clicked - processing:', { shareId, assetType, instanceNumber });
        
        // Disable button during processing
        const originalContent = shareButton.innerHTML;
        shareButton.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> SHARING...';
        shareButton.disabled = true;
        shareButton.style.backgroundColor = '#f59e0b';
        
        console.log('[DEBUG-WORKITEM:assetshare:continue] 🔄 Calling DotNet method ShareAsset...');
        
        // [DOM-TIMING] Log click timing for DOM debugging
        const clickTime = new Date().toISOString();
        const clickTimestamp = Date.now();
        console.log('[DOM-TIMING] Share button clicked at', clickTime, 'timestamp:', clickTimestamp);
        console.log('[DOM-TIMING] About to invoke KSESSIONS ShareAsset method');
        
        // TOAST: Show method call initiation
        showShareDebugToast('🔄 CALLING C# METHOD...', { shareId, assetType, instanceNumber }, 'info');
        
        // Call C# method via DotNet interop
        if (window.dotNetRef) {
            console.log('[DEBUG-WORKITEM:assetshare:continue] 📞 DotNet reference available, invoking ShareAsset...');
            
            // TOAST: Show DotNet reference status
            showShareDebugToast('📞 DOTNET REFERENCE FOUND', { hasReference: true, method: 'ShareAsset' }, 'success');
            
            window.dotNetRef.invokeMethodAsync('ShareAsset', shareId, assetType, instanceNumber)
                .then((result) => {
                    console.log('[DEBUG-WORKITEM:assetshare:continue] ✅ ShareAsset completed successfully:', result);
                    
                    // TOAST: Show success result
                    showShareDebugToast('🎉 SHARE SUCCESS!', result, 'success');
                    
                    // Success feedback
                    shareButton.innerHTML = '✅ SHARED!';
                    shareButton.style.backgroundColor = '#059669';
                    
                    // Restore button after 3 seconds
                    setTimeout(() => {
                        shareButton.innerHTML = originalContent;
                        shareButton.style.backgroundColor = '';
                        shareButton.disabled = false;
                    }, 3000);
                })
                .catch((error) => {
                    console.error('[DEBUG-WORKITEM:assetshare:continue] ❌ ShareAsset failed:', error);
                    
                    // TOAST: Show error details
                    showShareDebugToast('💥 SHARE FAILED!', { error: error.toString(), shareId, assetType }, 'error');
                    
                    // Error feedback
                    shareButton.innerHTML = '❌ ERROR';
                    shareButton.style.backgroundColor = '#dc2626';
                    
                    // Restore button after error
                    setTimeout(() => {
                        shareButton.innerHTML = originalContent;
                        shareButton.style.backgroundColor = '';
                        shareButton.disabled = false;
                    }, 3000);
                });
        } else {
            console.error('[DEBUG-WORKITEM:assetshare:continue] ❌ DotNet reference not available');
            
            // TOAST: Show DotNet reference error
            showShareDebugToast('❌ NO DOTNET REFERENCE', { hasReference: false, windowDotNetRef: !!window.dotNetRef }, 'error');
            
            alert('DotNet reference not available. Please refresh the page.');
            shareButton.innerHTML = originalContent;
            shareButton.style.backgroundColor = '';
            shareButton.disabled = false;
        }
    }
    
    // Enhanced Custom Asset Detection Popup using SweetAlert2
    window.showCustomAssetPopup = function(htmlContent, title) {
        try {
            console.log('[DEBUG-WORKITEM:popup:start] Attempting to show custom asset popup');
            console.log('[DEBUG-WORKITEM:popup:content-length] HTML content length:', htmlContent ? htmlContent.length : 0);
            
            // Check if SweetAlert2 is available
            if (typeof Swal === 'undefined') {
                console.error('[DEBUG-WORKITEM:popup:error] SweetAlert2 not available, using fallback');
                throw new Error('SweetAlert2 not loaded');
            }
            
            // Use SweetAlert2 for reliable HTML rendering
            Swal.fire({
                title: title || '🔍 Asset Detection Results',
                html: htmlContent,
                width: '90%',
                maxWidth: '900px',
                showCloseButton: true,
                showConfirmButton: false,
                allowOutsideClick: true,
                allowEscapeKey: true,
                customClass: {
                    popup: 'noor-asset-popup',
                    title: 'noor-popup-title',
                    htmlContainer: 'noor-popup-content'
                },
                didOpen: () => {
                    console.log('[DEBUG-WORKITEM:popup:success] SweetAlert2 popup opened successfully');
                    // Add custom styling
                    const popup = Swal.getPopup();
                    if (popup) {
                        popup.style.borderRadius = '20px';
                        popup.style.boxShadow = '0 25px 50px rgba(0, 0, 0, 0.25)';
                        
                        // Style the title
                        const title = popup.querySelector('.swal2-title');
                        if (title) {
                            title.style.background = 'linear-gradient(135deg, #4f46e5 0%, #7c3aed 50%, #ec4899 100%)';
                            title.style.color = 'white';
                            title.style.padding = '20px 30px';
                            title.style.margin = '-20px -20px 20px -20px';
                            title.style.borderRadius = '20px 20px 0 0';
                            title.style.textShadow = '0 2px 4px rgba(0, 0, 0, 0.1)';
                        }
                        
                        // Style the content area
                        const content = popup.querySelector('.swal2-html-container');
                        if (content) {
                            content.style.maxHeight = '70vh';
                            content.style.overflowY = 'auto';
                            content.style.padding = '20px';
                        }
                    }
                }
            });
            
            console.log('[DEBUG-WORKITEM:popup:complete] Custom asset popup displayed via SweetAlert2');
        } catch (error) {
            console.error('[DEBUG-WORKITEM:popup:error] Error in showCustomAssetPopup:', error);
            // Fallback to simple native popup if SweetAlert2 fails
            const simpleContent = htmlContent ? htmlContent.replace(/<[^>]*>/g, '') : 'Asset detection completed';
            alert(`${title || 'Asset Detection'}\n\n${simpleContent.substring(0, 500)}${simpleContent.length > 500 ? '...' : ''}`);
        }
    };
    
    // Note: CSS animations handled inline to avoid Razor parsing issues
    
    console.log('[DEBUG-WORKITEM:assetshare:continue] Share button JavaScript functions defined');
</script>

