{
  "api/index.html": {
    "href": "api/index.html",
    "title": "API Reference | NOOR CANVAS Documentation",
    "summary": "API Reference This section contains comprehensive API documentation for NOOR CANVAS components. Controllers SessionController Manages session creation, management, and lifecycle operations. ParticipantController Handles participant registration, authentication, and management. AnnotationController Processes real-time annotation data and synchronization. QuestionController Manages Q&A system functionality and responses. SignalR Hubs SessionHub Real-time session management and coordination. AnnotationHub Live annotation synchronization and canvas updates. ParticipantHub Participant connection management and status updates. QuestionHub Q&A system real-time communication. Models Core Models Session Participant Annotation Question SessionTranscript Request/Response Models CreateSessionRequest ParticipantRegistrationRequest AnnotationData QuestionResponse Services Business Logic Services SessionService AnnotationService ParticipantService NotificationService Note: Complete API documentation is generated automatically from source code comments."
  },
  "articles/development/getting-started.html": {
    "href": "articles/development/getting-started.html",
    "title": "Getting Started with NOOR CANVAS Development | NOOR CANVAS Documentation",
    "summary": "Getting Started with NOOR CANVAS Development Prerequisites Required Software Visual Studio 2022 or VS Code .NET 8.0 SDK SQL Server (Express or Developer Edition) Git for version control PowerShell 5.1+ for automation scripts Development Database Setup -- Development Environment USE KSESSIONS_DEV; -- Production Environment USE KSESSIONS; -- Canvas schema objects SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = 'canvas'; Project Setup 1. Clone Repository git clone https://github.com/asifhussain60/NOOR-CANVAS.git cd NOOR-CANVAS 2. Database Configuration Update connection strings in appsettings.json: { \"ConnectionStrings\": { \"DefaultConnection\": \"Server=.;Database=KSESSIONS_DEV;Trusted_Connection=true;MultipleActiveResultSets=true;Timeout=3600\" } } 3. Build and Run Using NC Command (Recommended) # Navigate to workspace root cd \"D:\\PROJECTS\\NOOR CANVAS\" # Generate host token (optional) nct # Build and run application nc Manual Build Process # Navigate to project directory cd \"D:\\PROJECTS\\NOOR CANVAS\\SPA\\NoorCanvas\" # Restore packages dotnet restore # Build project dotnet build --no-restore # Run application dotnet run --urls \"https://localhost:9091\" Development Workflow 1. Application Startup Application runs on IIS Express x64 Primary URL: https://localhost:9091 (HTTPS) Fallback URL: http://localhost:9090 (HTTP) Blazor Server with SignalR enabled 2. Development Tools NC Command Suite nc # Full application startup nc -SkipTokenGeneration # Skip host token step nc -Help # Command reference Health Checks # Verify application health Invoke-WebRequest -Uri \"https://localhost:9091/healthz\" -SkipCertificateCheck # Check SignalR connectivity Invoke-WebRequest -Uri \"https://localhost:9091/hub/session\" -SkipCertificateCheck 3. Testing Framework Automated Testing # Run all tests dotnet test # Run specific test project dotnet test Tests/NoorCanvas.Core.Tests/ # Run with coverage dotnet test --collect:\"XPlat Code Coverage\" Manual Testing Browser: Navigate to https://localhost:9091 Developer Tools: Check console for errors Network Tab: Verify SignalR connections Application Tab: Check local storage Development Environment Verification 1. Port Verification # Check if ports are in use netstat -ano | findstr \":9091\" # HTTPS netstat -ano | findstr \":9090\" # HTTP 2. Process Verification # Check IIS Express processes Get-Process | Where-Object {$_.ProcessName -like \"*iisexpress*\"} # Check .NET processes Get-Process | Where-Object {$_.ProcessName -like \"*dotnet*\"} 3. Database Connectivity -- Test canvas schema access USE KSESSIONS_DEV; SELECT COUNT(*) FROM canvas.Sessions; -- Test cross-schema access USE KQUR_DEV; SELECT COUNT(*) FROM dbo.Users; Common Development Issues Build Errors Issue: Restore failures Solution: Clear NuGet cache: dotnet nuget locals all --clear Port Conflicts Issue: Port 9091 already in use Solution: Kill existing processes: Stop-Process -Name \"dotnet\" -Force Database Connection Issue: Connection timeout Solution: Verify SQL Server service and connection string SignalR Issues Issue: WebSocket failures Solution: Check browser developer tools for connection errors Project Structure SPA/NoorCanvas/ # Main application ├── Controllers/ # Web API controllers ├── Hubs/ # SignalR hubs ├── Models/ # Data models ├── Services/ # Business logic ├── Components/ # Blazor components ├── wwwroot/ # Static files └── Views/ # Razor views Tests/ # Test projects ├── NoorCanvas.Core.Tests/ # Unit tests └── NC-ImplementationTests/ # Integration tests Tools/ # Console applications └── HostProvisioner/ # Host token generator Workspaces/ # Documentation and tools ├── Documentation/ # Project documentation ├── Global/ # Global scripts (nc, nct) └── TEMP/ # Temporary development files Next Steps Explore Components: Review Blazor components in Components/ Understand SignalR: Examine hubs in Hubs/ Database Integration: Study models and DbContext Testing: Run test suite to verify setup Phase 4 Development: Begin mock template conversion For deployment instructions, see the Deployment Guide"
  },
  "articles/development/host-token-quick-reference.html": {
    "href": "articles/development/host-token-quick-reference.html",
    "title": "Host Token User Guide | NOOR CANVAS Documentation",
    "summary": "Host Token User Guide A simple guide for session hosts and administrators to understand host authentication What is Host Authentication? Host authentication is a security system that verifies you are authorized to manage Islamic content sharing sessions. Think of it like a digital key that proves you have permission to: Create new sessions for Qur'anic studies, Islamic discussions, or religious content sharing Manage participant access and session settings Control session flow including Q&A, annotations, and real-time interactions How Does It Work? 1. Getting Your Host Access When you need to host a session, the system administrator will provide you with: A Host Access Code (a unique identifier) Instructions on how to use it to access your host dashboard 2. Accessing Your Host Dashboard Once you have your Host Access Code: Open your web browser Navigate to the NOOR Canvas platform Enter your Host Access Code when prompted Access your personalized host dashboard 3. Managing Your Sessions From your host dashboard, you can: Create new sessions for Islamic content sharing View participant lists and manage access Start and end sessions as needed Monitor Q&A activity and participant engagement Common Scenarios Starting a New Qur'anic Study Session Access your host dashboard using your Host Access Code Click \"Create New Session\" Choose your content type (Qur'anic verses, Islamic commentary, etc.) Set session parameters (duration, participant limits) Share the session link with participants Begin your session when ready Managing Participant Q&A Monitor incoming questions during your session Choose which questions to address publicly Provide answers that appear to all participants Moderate discussions to maintain Islamic etiquette Reviewing Session Activity Access session transcripts after completion Review participant annotations and contributions Export session content for future reference Plan follow-up sessions based on participant feedback Getting Help If You Can't Access Your Host Dashboard Contact your system administrator Verify you're using the correct Host Access Code Check that you're on the correct NOOR Canvas website Ensure your internet connection is stable If Participants Can't Join Your Session Verify the session is active and not expired Check that you've shared the correct session link Confirm participant limits haven't been reached Contact technical support if issues persist For Session Management Questions Review the Host Dashboard user guide Contact your Islamic content coordinator Reach out to technical support for platform issues Consult the FAQ section for common questions Best Practices for Islamic Content Sessions Before Your Session Prepare your content in advance with appropriate Islamic references Test your host access to ensure everything works properly Set clear session objectives aligned with Islamic educational goals Prepare discussion questions that encourage thoughtful participation During Your Session Maintain Islamic etiquette in all interactions Encourage respectful dialogue among participants Stay focused on the session's Islamic educational objectives Monitor time to ensure adequate coverage of planned material After Your Session Review session transcripts for valuable insights Follow up with participants who had questions Plan future sessions based on community interest Share session summaries with appropriate community members Need Technical Help? This user guide focuses on understanding and using host authentication from a user perspective. If you need technical implementation details, API references, or troubleshooting code, please refer to the Host Token Technical Documentation. For immediate technical support, contact your system administrator or IT support team. Generate and Authenticate // Generate new token const generateResponse = await fetch('/api/hostprovisioner/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sessionId: 100, createdBy: 'Web User' }) }); const { hostGuid } = await generateResponse.json(); // Authenticate token const authResponse = await fetch('/api/host/authenticate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ hostGuid }) }); const authData = await authResponse.json(); if (authData.success) { localStorage.setItem('sessionToken', authData.sessionToken); window.location.href = '/host/dashboard'; } Troubleshooting Common Errors 400 Bad Request: Invalid GUID format Check GUID has correct format: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx Ensure no extra characters or spaces Authentication Error Dialog Verify JSON property naming (camelCase vs PascalCase) Check CORS configuration Confirm API endpoints are accessible 500 Internal Server Error Check server logs for detailed error information Verify application is running on correct ports (9090/9091) Ensure database connection is available Logging Keywords Monitor logs for these NOOR prefixes: NOOR-HOSTPROV: - Token generation events NOOR-INFO: - Authentication attempts NOOR-SUCCESS: - Successful operations NOOR-ERROR: - Error conditions Current Implementation Status Phase 2 (Active) ✅ ✅ GUID generation working ✅ HMAC-SHA256 hashing implemented ✅ Format validation active ✅ Session token creation functional ✅ Accepts any valid GUID format for development Future Phases \uD83D\uDD04 Database storage (Phase 3) \uD83D\uDD04 Hash verification (Phase 3) \uD83D\uDD04 Token expiration (Phase 3) \uD83D\uDD04 Administrative revocation (Phase 4) Links Complete Documentation Security Model API Reference"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Introduction to NOOR CANVAS | NOOR CANVAS Documentation",
    "summary": "Introduction to NOOR CANVAS NOOR CANVAS is an innovative Islamic content sharing platform that enables real-time collaboration and annotation on Islamic educational content. Key Features Real-time Collaboration Live annotation and drawing capabilities Synchronized participant interactions Host-controlled session management Q&A system with live responses Islamic Content Integration Qur'anic verses with Arabic text support Hadith collections and references Etymology and linguistic analysis Islamic poetry and literature Multi-language Support Arabic (RTL) text rendering English (LTR) interface Urdu (RTL) support Cultural sensitivity in design Modern Architecture ASP.NET Core 8.0 with Blazor Server SignalR for real-time communication Entity Framework Core data access SQL Server with optimized schema Target Audience Host Users (Educators) Islamic scholars and teachers Community leaders and imams Educational institution instructors Religious study group facilitators Participants (Students) Students of Islamic studies Community members Online learners Study group participants Platform Benefits For Hosts Interactive teaching tools Real-time feedback from participants Session recording and transcription Participant engagement analytics For Participants Active learning experience Direct interaction with content Question and answer capabilities Multi-device accessibility Technical Innovation NOOR CANVAS combines modern web technologies with Islamic educational needs: Real-time Canvas: HTML5 canvas with SignalR synchronization Cultural Design: McBeatch theme with Islamic aesthetic Performance Optimized: Efficient real-time data transmission Secure Architecture: GUID-based session management Continue reading: Technical Architecture"
  },
  "articles/technical/architecture.html": {
    "href": "articles/technical/architecture.html",
    "title": "NOOR CANVAS Technical Architecture | NOOR CANVAS Documentation",
    "summary": "NOOR CANVAS Technical Architecture System Overview NOOR CANVAS is built on a modern, scalable architecture designed for real-time Islamic content sharing and collaboration. Core Technologies Backend Framework ASP.NET Core 8.0 with Blazor Server Entity Framework Core for data access SignalR for real-time communication Serilog for structured logging Database SQL Server with dedicated canvas schema Cross-application integration with existing dbo schema GUID-based session management Optimized indexes for real-time performance Frontend Blazor Server with real-time rendering McBeatch responsive theme framework Multi-language support (Arabic RTL, English LTR, Urdu RTL) Canvas-based annotation system Real-time Communication SignalR WebSocket connections Hub-based architecture for session management Live annotation synchronization Participant management and Q&A system Architecture Layers 1. Presentation Layer (Blazor Server) Components/ ├── Session Management ├── Annotation Canvas ├── Participant Interface └── Q&A System 2. Application Layer Controllers/ ├── SessionController ├── ParticipantController ├── AnnotationController └── QuestionController Services/ ├── SessionService ├── AnnotationService ├── ParticipantService └── NotificationService 3. SignalR Hubs Hubs/ ├── SessionHub (session management) ├── AnnotationHub (real-time drawing) ├── ParticipantHub (user management) └── QuestionHub (Q&A system) 4. Data Layer Models/ ├── Session ├── Participant ├── Annotation ├── Question └── SessionTranscript DbContext/ └── CanvasDbContext (canvas schema) 5. Database Schema Canvas Schema (NOOR CANVAS) canvas.Sessions - Session management canvas.SessionTranscripts - Session content canvas.Registrations - Participant data canvas.Questions - Q&A system canvas.Annotations - Drawing data Cross-Schema Integration Read access to existing dbo schema Asset referencing (no duplication) Shared authentication context Development Environment Required Setup IIS Express x64 (localhost:9091 HTTPS) SQL Server with canvas schema Visual Studio or VS Code PowerShell for automation scripts Key Development Tools nc command for application startup nct for host token generation Automated testing framework NOOR Observer debugging system Deployment Architecture Production Environment IIS with dedicated application pool SQL Server production databases HTTPS with SSL certificates Application Insights monitoring Security Features GUID-based session tokens SQL injection prevention Cross-schema access controls Structured logging with sanitization Performance Considerations Real-time Optimization SignalR connection pooling Minimal message payloads Client-side caching Database query optimization Scalability Stateless session design Database connection pooling CDN integration for static assets Load balancing support For detailed implementation information, see the Development Guide"
  },
  "articles/technical/database-schema.html": {
    "href": "articles/technical/database-schema.html",
    "title": "Database Schema Documentation | NOOR CANVAS Documentation",
    "summary": "Database Schema Documentation Overview NOOR CANVAS uses a dedicated canvas schema within SQL Server, designed for optimal performance with real-time operations. Schema Structure Development Environment Database: KSESSIONS_DEV Schema: canvas Connection: Trusted connection with 1-hour timeout Production Environment Database: KSESSIONS Schema: canvas Connection: sa user with full permissions Tables canvas.Sessions Primary session management table. CREATE TABLE canvas.Sessions ( id INT IDENTITY(1,1) PRIMARY KEY, album_id INT NULL, category_id INT NULL, guid UNIQUEIDENTIFIER NOT NULL DEFAULT NEWID(), host_token UNIQUEIDENTIFIER NOT NULL, status NVARCHAR(50) NOT NULL DEFAULT 'Active', created_at DATETIME2 NOT NULL DEFAULT GETUTCDATE(), expires_at DATETIME2 NULL, INDEX IX_Sessions_Guid (guid), INDEX IX_Sessions_HostToken (host_token), INDEX IX_Sessions_Status (status) ); canvas.SessionTranscripts Stores session content and transcription data. CREATE TABLE canvas.SessionTranscripts ( id INT IDENTITY(1,1) PRIMARY KEY, session_id INT NOT NULL, html_content NVARCHAR(MAX) NULL, created_at DATETIME2 NOT NULL DEFAULT GETUTCDATE(), FOREIGN KEY (session_id) REFERENCES canvas.Sessions(id), INDEX IX_SessionTranscripts_SessionId (session_id) ); canvas.Registrations Participant registration and management. CREATE TABLE canvas.Registrations ( id INT IDENTITY(1,1) PRIMARY KEY, session_id INT NOT NULL, name NVARCHAR(255) NOT NULL, country NVARCHAR(100) NULL, city NVARCHAR(100) NULL, fingerprint_hash NVARCHAR(64) NOT NULL, ip_hash NVARCHAR(64) NOT NULL, join_time DATETIME2 NOT NULL DEFAULT GETUTCDATE(), FOREIGN KEY (session_id) REFERENCES canvas.Sessions(id), INDEX IX_Registrations_SessionId (session_id), INDEX IX_Registrations_FingerprintHash (fingerprint_hash) ); canvas.Questions Q&A system data storage. CREATE TABLE canvas.Questions ( id INT IDENTITY(1,1) PRIMARY KEY, session_id INT NOT NULL, participant_id INT NOT NULL, question_text NVARCHAR(MAX) NOT NULL, answer_text NVARCHAR(MAX) NULL, status NVARCHAR(50) NOT NULL DEFAULT 'Pending', created_at DATETIME2 NOT NULL DEFAULT GETUTCDATE(), FOREIGN KEY (session_id) REFERENCES canvas.Sessions(id), FOREIGN KEY (participant_id) REFERENCES canvas.Registrations(id), INDEX IX_Questions_SessionId (session_id), INDEX IX_Questions_ParticipantId (participant_id), INDEX IX_Questions_Status (status) ); canvas.Annotations Real-time annotation data storage. CREATE TABLE canvas.Annotations ( id INT IDENTITY(1,1) PRIMARY KEY, session_id INT NOT NULL, participant_id INT NOT NULL, annotation_data NVARCHAR(MAX) NOT NULL, created_at DATETIME2 NOT NULL DEFAULT GETUTCDATE(), FOREIGN KEY (session_id) REFERENCES canvas.Sessions(id), FOREIGN KEY (participant_id) REFERENCES canvas.Registrations(id), INDEX IX_Annotations_SessionId (session_id), INDEX IX_Annotations_ParticipantId (participant_id), INDEX IX_Annotations_CreatedAt (created_at) ); Cross-Schema Integration Read Access to dbo Schema NOOR CANVAS has read access to existing application data: -- Beautiful Islam integration USE KQUR_DEV; -- Development USE KQUR; -- Production -- Available tables SELECT * FROM dbo.Users; SELECT * FROM dbo.Categories; SELECT * FROM dbo.Albums; Asset Referencing Strategy No Data Duplication: Reference existing image paths Shared Resources: Use existing asset directories Path References: D:\\PROJECTS\\KSESSIONS\\Source Code\\Sessions.Spa\\Resources\\IMAGES Performance Optimizations Indexing Strategy GUID Lookups: Optimized for session token validation Time-based Queries: Indexed on creation timestamps Foreign Key Relationships: Proper referential integrity Real-time Queries: Optimized for annotation retrieval Query Performance Connection Pooling: Efficient database connections Timeout Configuration: 1-hour timeout for long operations Prepared Statements: Parameterized queries for security Bulk Operations: Optimized for real-time data insertion Security Considerations Data Protection Parameterized Queries: SQL injection prevention Hash Storage: Fingerprint and IP address hashing GUID Tokens: Cryptographically secure session tokens Schema Isolation: Dedicated canvas schema separation Access Control Minimal Permissions: Read-only access to dbo schema Service Account: Dedicated application database user Connection Security: Trusted connections in development Audit Trail: Comprehensive logging for all operations For development setup instructions, see Getting Started"
  },
  "articles/technical/host-token-system.html": {
    "href": "articles/technical/host-token-system.html",
    "title": "NOOR Canvas Host Token Generation and Validation System | NOOR CANVAS Documentation",
    "summary": "NOOR Canvas Host Token Generation and Validation System Overview The NOOR Canvas Host Token System provides secure authentication for session hosts using GUID-based tokens with HMAC-SHA256 validation. The system consists of two main components: Token Generation and Token Authentication, designed for both development flexibility and production security. Table of Contents System Architecture Token Generation Process Token Validation Process Security Model API Reference Implementation Phases Usage Examples Troubleshooting System Architecture Component Overview graph LR A[Host Request] --> B[HostProvisionerController] B --> C[GUID Generation] C --> D[HMAC-SHA256 Hash] D --> E[Token Response] F[Authentication Request] --> G[HostController] G --> H[GUID Validation] H --> I[Session Token] Core Components HostProvisionerController: Generates new host tokens (database-independent) HostController: Validates host tokens and creates session tokens HMAC-SHA256: Cryptographic hash function for token integrity Session Management: Links host tokens to active sessions Token Generation Process Step 1: Token Request The token generation process begins when a host requests a new authentication token. API Endpoint: POST /api/hostprovisioner/generate Request Structure: { \"sessionId\": 100, \"createdBy\": \"Host Name\" } Step 2: GUID Generation A new UUID (Version 4) is generated using .NET's Guid.NewGuid() method: var hostGuid = Guid.NewGuid(); // Example: \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" GUID Format: Length: 36 characters (32 hex digits + 4 hyphens) Standard: RFC 4122 compliant UUID Version 4 Entropy: 122 bits of randomness Collision Probability: ~5.3 x 10^-37 Step 3: Hash Generation Each GUID is cryptographically signed using HMAC-SHA256: private static string ComputeHash(string input) { using var hmac = new HMACSHA256(Encoding.UTF8.GetBytes(AppSecret)); var hashBytes = hmac.ComputeHash(Encoding.UTF8.GetBytes(input)); return Convert.ToBase64String(hashBytes); } Security Properties: Algorithm: HMAC-SHA256 Secret Key: \"NOOR-CANVAS-HOST-SECRET-2025\" Output: Base64-encoded hash (44 characters) Integrity: Tampering detection capability Step 4: Response Generation The system returns a comprehensive token response: { \"hostGuid\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\", \"sessionId\": 100, \"createdBy\": \"Host Name\", \"createdAt\": \"2025-09-13T15:30:00Z\", \"hash\": \"A1B2C3D4E5F6G7H8...\" } Token Validation Process Phase 2 Implementation (Current) The current validation system is designed for development and testing: [HttpPost(\"authenticate\")] public async Task<IActionResult> AuthenticateHost([FromBody] HostAuthRequest request) { // 1. GUID Format Validation if (!Guid.TryParse(request.HostGuid, out Guid hostGuid)) { return BadRequest(new { error = \"Invalid GUID format\" }); } // 2. Session Token Generation (Phase 2: Accept any valid GUID) var sessionToken = Guid.NewGuid().ToString(); // 3. Authentication Response return Ok(new HostAuthResponse { Success = true, SessionToken = sessionToken, ExpiresAt = DateTime.UtcNow.AddHours(8), HostGuid = hostGuid.ToString() }); } Validation Steps Format Validation: Ensures GUID follows RFC 4122 standard Session Token Creation: Generates new session-specific token Response Generation: Returns authentication credentials Future Enhancement (Phase 3+) Planned database integration for production validation: // Future implementation will include: var storedToken = await _context.HostTokens .FirstOrDefaultAsync(t => t.HostGuid == hostGuid && t.IsActive); if (storedToken == null || !ValidateHash(storedToken)) { return Unauthorized(\"Invalid or expired token\"); } Security Model Cryptographic Security HMAC-SHA256 Properties: Key Size: 256 bits Hash Output: 256 bits (32 bytes) Resistance: Preimage, second preimage, and collision resistant Performance: ~10,000 operations per second typical throughput Security Guarantees: Integrity: Hash verification prevents token tampering Authenticity: HMAC proves token was generated by authorized system Non-repudiation: Cryptographic proof of token origin Token Lifecycle stateDiagram-v2 [*] --> Generated: Host requests token Generated --> Authenticated: Valid GUID provided Generated --> Expired: Timeout (future) Authenticated --> SessionActive: Session token created SessionActive --> SessionExpired: 8 hours timeout SessionExpired --> [*] Expired --> [*] Lifecycle Stages: Generated: Token created and returned to host Authenticated: Token used for successful authentication Session Active: Host has valid session (8-hour lifespan) Session Expired: Session timeout, re-authentication required Phase 2 vs Production Security Aspect Phase 2 (Current) Production (Future) Validation Format only Database + Hash verification Storage None Encrypted database storage Expiration Session-based only Token + Session expiration Revocation Not implemented Administrative revocation Audit Trail Basic logging Comprehensive audit logs API Reference Generate Host Token Endpoint: POST /api/hostprovisioner/generate Request Headers: Content-Type: application/json Request Body: { \"sessionId\": integer, // Required: Session identifier \"createdBy\": \"string\" // Optional: Host identifier } Response (200 OK): { \"hostGuid\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\", \"sessionId\": 100, \"createdBy\": \"Host Name\", \"createdAt\": \"2025-09-13T15:30:00Z\", \"hash\": \"A1B2C3D4E5F6G7H8I9J0K1L2M3N4...\" } Error Responses: 500 Internal Server Error: Token generation failed Authenticate Host Token Endpoint: POST /api/host/authenticate Request Headers: Content-Type: application/json Request Body: { \"hostGuid\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" } Response (200 OK): { \"success\": true, \"sessionToken\": \"a8b9c0d1-e2f3-4567-8901-234567890123\", \"expiresAt\": \"2025-09-13T23:30:00Z\", \"hostGuid\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" } Error Responses: 400 Bad Request: Invalid GUID format 401 Unauthorized: Invalid token (future implementation) 500 Internal Server Error: Authentication system error Implementation Phases Phase 1: Foundation ✅ Basic GUID generation HMAC-SHA256 implementation API endpoint structure Phase 2: Development System ✅ (Current) Format validation only Session token generation Basic authentication flow Development-friendly (accepts any valid GUID) Phase 3: Database Integration (Planned) Token storage in database Hash validation Token expiration handling Revocation capabilities Phase 4: Production Security (Planned) Advanced validation Audit logging Performance optimization Security monitoring Usage Examples Generating a Host Token Using PowerShell: $request = @{ sessionId = 100 createdBy = \"Conference Host\" } | ConvertTo-Json $response = Invoke-RestMethod -Uri \"https://localhost:9091/api/hostprovisioner/generate\" ` -Method Post -Body $request -ContentType \"application/json\" ` -SkipCertificateCheck Write-Host \"Host GUID: $($response.hostGuid)\" Using cURL: curl -X POST https://localhost:9091/api/hostprovisioner/generate \\ -H \"Content-Type: application/json\" \\ -d '{\"sessionId\": 100, \"createdBy\": \"Conference Host\"}' \\ -k Authenticating with Host Token Using PowerShell: $authRequest = @{ hostGuid = \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" } | ConvertTo-Json $authResponse = Invoke-RestMethod -Uri \"https://localhost:9091/api/host/authenticate\" ` -Method Post -Body $authRequest -ContentType \"application/json\" ` -SkipCertificateCheck Write-Host \"Session Token: $($authResponse.sessionToken)\" Write-Host \"Expires At: $($authResponse.expiresAt)\" Browser Integration JavaScript Example: // Generate host token async function generateHostToken() { const response = await fetch('/api/hostprovisioner/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sessionId: 100, createdBy: 'Web Host' }) }); const data = await response.json(); return data.hostGuid; } // Authenticate host token async function authenticateHost(hostGuid) { const response = await fetch('/api/host/authenticate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ hostGuid }) }); const authData = await response.json(); if (authData.success) { localStorage.setItem('sessionToken', authData.sessionToken); window.location.href = '/host/dashboard'; } } Troubleshooting Common Issues 1. Invalid GUID Format Error Problem: 400 Bad Request: Invalid GUID format Causes: Malformed GUID string Missing hyphens in GUID Non-hexadecimal characters Solution: // Correct GUID format \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" // Invalid formats \"f47ac10b58cc43720e02b2c3d479\" // Missing hyphens \"g47ac10b-58cc-4372-a567-0e02b2c3d479\" // Invalid character 'g' 2. JSON Serialization Issues Problem: Authentication fails with valid GUID Root Cause: Property name case mismatch between client and server Solution: Configure camelCase JSON serialization: builder.Services.AddControllers() .AddJsonOptions(options => { options.JsonSerializerOptions.PropertyNamingPolicy = System.Text.Json.JsonNamingPolicy.CamelCase; }); 3. CORS Issues Problem: Browser requests blocked by CORS policy Solution: Verify CORS configuration includes all required origins: builder.Services.AddCors(options => { options.AddDefaultPolicy(builder => { builder.WithOrigins(\"https://localhost:9091\", \"http://localhost:9090\") .AllowAnyHeader() .AllowAnyMethod(); }); }); Debugging Tools Logging Analysis Monitor these log patterns for troubleshooting: [INFO] NOOR-HOSTPROV: Generating host token for session 100 [INFO] NOOR-HOSTPROV: Host token generated successfully for session 100 [INFO] NOOR-INFO: Host authentication attempt for GUID: f47ac10b... [SUCCESS] NOOR-SUCCESS: Host GUID format validated [ERROR] NOOR-ERROR: Host authentication failed Testing Endpoints Status Check: curl -X GET https://localhost:9091/api/hostprovisioner/status -k Expected Response: { \"status\": \"operational\", \"service\": \"HostProvisioner API\", \"timestamp\": \"2025-09-13T15:30:00Z\" } Developer Quick Reference Ready-to-Use Test Tokens For development and testing, use these pre-validated GUIDs: f47ac10b-58cc-4372-a567-0e02b2c3d479 3cbd173a-a146-4049-9f50-e33eb9ee2f2c fa4a5e78-6ebd-4fad-bd9f-95e214e0c3cf Quick Commands Generate Token (cURL) curl -X POST https://localhost:9091/api/hostprovisioner/generate \\ -H \"Content-Type: application/json\" \\ -d '{\"sessionId\": 100, \"createdBy\": \"Your Name\"}' \\ -k Authenticate Token (cURL) curl -X POST https://localhost:9091/api/host/authenticate \\ -H \"Content-Type: application/json\" \\ -d '{\"hostGuid\": \"f47ac10b-58cc-4372-a567-0e02b2c3d479\"}' \\ -k PowerShell Quick Commands Generate New Token: $request = @{ sessionId = 100; createdBy = \"Test User\" } | ConvertTo-Json $response = Invoke-RestMethod -Uri \"https://localhost:9091/api/hostprovisioner/generate\" -Method Post -Body $request -ContentType \"application/json\" -SkipCertificateCheck Write-Host \"New Host GUID: $($response.hostGuid)\" Test Authentication: $auth = @{ hostGuid = \"f47ac10b-58cc-4372-a567-0e02b2c3d479\" } | ConvertTo-Json $result = Invoke-RestMethod -Uri \"https://localhost:9091/api/host/authenticate\" -Method Post -Body $auth -ContentType \"application/json\" -SkipCertificateCheck Write-Host \"Success: $($result.success)\" Write-Host \"Session Token: $($result.sessionToken)\" Direct Dashboard Access Navigate to: https://localhost:9091/host/dashboard?guid=YOUR-GUID Integration Examples JavaScript Client Integration class HostTokenManager { constructor(baseUrl = 'https://localhost:9091') { this.baseUrl = baseUrl; } async generateToken(sessionId, createdBy) { try { const response = await fetch(`${this.baseUrl}/api/hostprovisioner/generate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ sessionId, createdBy }) }); return await response.json(); } catch (error) { console.error('Token generation failed:', error); throw error; } } async authenticate(hostGuid) { try { const response = await fetch(`${this.baseUrl}/api/host/authenticate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ hostGuid }) }); return await response.json(); } catch (error) { console.error('Authentication failed:', error); throw error; } } } // Usage const tokenManager = new HostTokenManager(); const token = await tokenManager.generateToken(100, \"JavaScript Host\"); const auth = await tokenManager.authenticate(token.hostGuid); C# Client Integration public class HostTokenClient { private readonly HttpClient _httpClient; private readonly string _baseUrl; public HostTokenClient(HttpClient httpClient, string baseUrl = \"https://localhost:9091\") { _httpClient = httpClient; _baseUrl = baseUrl; } public async Task<HostTokenResponse> GenerateTokenAsync(int sessionId, string createdBy) { var request = new { sessionId, createdBy }; var json = JsonSerializer.Serialize(request); var content = new StringContent(json, Encoding.UTF8, \"application/json\"); var response = await _httpClient.PostAsync($\"{_baseUrl}/api/hostprovisioner/generate\", content); response.EnsureSuccessStatusCode(); var responseJson = await response.Content.ReadAsStringAsync(); return JsonSerializer.Deserialize<HostTokenResponse>(responseJson); } public async Task<HostAuthResponse> AuthenticateAsync(string hostGuid) { var request = new { hostGuid }; var json = JsonSerializer.Serialize(request); var content = new StringContent(json, Encoding.UTF8, \"application/json\"); var response = await _httpClient.PostAsync($\"{_baseUrl}/api/host/authenticate\", content); response.EnsureSuccessStatusCode(); var responseJson = await response.Content.ReadAsStringAsync(); return JsonSerializer.Deserialize<HostAuthResponse>(responseJson); } } Performance Considerations Token Generation Performance Throughput: ~1,000 tokens/second typical Memory Usage: <1KB per token operation CPU Impact: Minimal (cryptographic operations optimized) Database Considerations (Future) For Phase 3+ database integration: -- Recommended indexes CREATE INDEX IX_HostTokens_HostGuid ON HostTokens(HostGuid); CREATE INDEX IX_HostTokens_CreatedAt ON HostTokens(CreatedAt); CREATE INDEX IX_HostTokens_IsActive ON HostTokens(IsActive) WHERE IsActive = 1; Related Documentation NOOR Canvas Security Model Authentication Integration Guide Database Schema Reference API Reference Guide Version History Version Date Changes 1.0.0 2025-09-13 Initial documentation 1.1.0 2025-09-13 Added Phase 2 implementation details 1.2.0 2025-09-13 Enhanced troubleshooting section This documentation is part of the NOOR Canvas project. For technical support, please refer to the project issue tracker."
  },
  "articles/technical/security-model.html": {
    "href": "articles/technical/security-model.html",
    "title": "Security Model | NOOR CANVAS Documentation",
    "summary": "Security Model Overview NOOR CANVAS implements a comprehensive security model designed for Islamic educational content sharing with emphasis on data protection, secure communication, and user privacy. Authentication & Authorization GUID-based Session Management NOOR CANVAS uses a novel GUID-based authentication system instead of traditional user accounts: public class SessionSecurity { // Host token generation (cryptographically secure) public Guid GenerateHostToken() { return Guid.NewGuid(); // UUIDv4 - 128-bit random identifier } // Session validation public async Task<bool> ValidateSessionAccess(Guid sessionGuid, Guid hostToken) { var session = await _context.Sessions .FirstOrDefaultAsync(s => s.Guid == sessionGuid && s.HostToken == hostToken); return session != null && session.Status == \"Active\"; } } No Traditional Authentication Required No Passwords: Eliminates password-related security risks Token-based Access: Secure GUID tokens for session access Time-limited Sessions: Automatic expiration for security Host Control: Session creators have full administrative control Data Protection Database Security SQL Injection Prevention // All queries use parameterized statements public async Task<Session> GetSessionAsync(Guid sessionGuid) { return await _context.Sessions .Where(s => s.Guid == sessionGuid) // Parameterized automatically .FirstOrDefaultAsync(); } Schema Isolation Dedicated Canvas Schema: Isolated from other application data Minimal Cross-Schema Access: Read-only access to dbo schema Proper Permissions: Service account with minimal required privileges Sensitive Data Handling public class ParticipantSecurity { // Hash sensitive data before storage public string HashFingerprint(string fingerprint) { using var sha256 = SHA256.Create(); var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(fingerprint + _salt)); return Convert.ToBase64String(hashBytes); } // IP address hashing for privacy public string HashIpAddress(string ipAddress) { using var sha256 = SHA256.Create(); var hashBytes = sha256.ComputeHash(Encoding.UTF8.GetBytes(ipAddress + _salt)); return Convert.ToBase64String(hashBytes); } } Communication Security HTTPS Enforcement // Startup configuration public void Configure(IApplicationBuilder app, IWebHostEnvironment env) { if (!env.IsDevelopment()) { app.UseHsts(); // HTTP Strict Transport Security app.UseHttpsRedirection(); // Force HTTPS } // Security headers app.Use((context, next) => { context.Response.Headers.Add(\"X-Content-Type-Options\", \"nosniff\"); context.Response.Headers.Add(\"X-Frame-Options\", \"DENY\"); context.Response.Headers.Add(\"X-XSS-Protection\", \"1; mode=block\"); return next(); }); } SignalR Security public class SecureHub : Hub { public override async Task OnConnectedAsync() { var sessionId = Context.GetHttpContext()?.Request.Query[\"sessionId\"]; var hostToken = Context.GetHttpContext()?.Request.Query[\"hostToken\"]; // Validate session access before allowing connection if (!await _securityService.ValidateAccess(sessionId, hostToken)) { _logger.LogWarning(\"Unauthorized SignalR connection attempt from {ConnectionId}\", Context.ConnectionId); Context.Abort(); return; } await base.OnConnectedAsync(); } // Message validation for all hub methods public async Task SendMessage(string sessionId, string message) { if (!await ValidateMessageContent(message)) { await Clients.Caller.SendAsync(\"Error\", \"Invalid message content\"); return; } await Clients.Group(sessionId).SendAsync(\"ReceiveMessage\", message); } } Input Validation & Sanitization Content Security public class ContentValidator { public bool ValidateAnnotationData(AnnotationData annotation) { // Validate coordinate ranges if (annotation.Coordinates?.Any(c => c < 0 || c > 2000) == true) return false; // Validate color format (hex colors only) if (!Regex.IsMatch(annotation.Color ?? \"\", @\"^#[0-9A-Fa-f]{6}$\")) return false; // Validate thickness range if (annotation.Thickness < 1 || annotation.Thickness > 50) return false; return true; } public string SanitizeTextInput(string input) { if (string.IsNullOrWhiteSpace(input)) return string.Empty; // Remove potentially dangerous HTML return HttpUtility.HtmlEncode(input.Trim()); } } Islamic Content Considerations Cultural Sensitivity: Validation of appropriate content Arabic Text Validation: RTL text handling and validation Religious Content Filtering: Ensures appropriate Islamic educational content Privacy Protection Participant Privacy public class PrivacyService { public ParticipantDisplay CreatePublicProfile(Participant participant) { return new ParticipantDisplay { DisplayName = SanitizeName(participant.Name), Country = participant.Country, // Optional, user-provided City = participant.City, // Optional, user-provided JoinTime = participant.JoinTime, // Never expose: IP, fingerprint hashes, internal IDs }; } } Data Minimization Collect Only Necessary Data: Minimal participant information Automatic Data Cleanup: Session data expiration No Persistent Tracking: Session-based interaction only Optional Geographic Data: User choice for location sharing Logging & Monitoring Security Secure Logging public class SecureLogger { public void LogSecurityEvent(string eventType, object data) { var sanitizedData = SanitizeLogData(data); _logger.LogWarning(\"NOOR-SECURITY: {EventType} - {Data}\", eventType, JsonSerializer.Serialize(sanitizedData)); } private object SanitizeLogData(object data) { // Remove sensitive fields from log data var json = JsonSerializer.Serialize(data); var doc = JsonDocument.Parse(json); // Remove sensitive properties var sanitized = RemoveSensitiveFields(doc.RootElement, [\"password\", \"token\", \"hash\", \"fingerprint\", \"ip\"]); return sanitized; } } Security Monitoring Failed Authentication Attempts: Track invalid session access Suspicious Activity: Monitor unusual annotation patterns Rate Limiting: Prevent abuse and spam Connection Monitoring: Track SignalR connection anomalies Compliance & Best Practices Islamic Ethics in Security Trust and Transparency: Clear security practices Privacy Respect: Minimal data collection aligned with Islamic values Community Safety: Protection from harmful content Educational Focus: Security measures support learning objectives Technical Security Standards OWASP Compliance: Following web security best practices Data Encryption: In-transit and at-rest encryption Regular Security Reviews: Ongoing security assessment Vulnerability Management: Prompt security updates Development Security Secure Development Practices // Example: Secure configuration management public class SecurityConfiguration { public void ConfigureServices(IServiceCollection services) { // Secure session configuration services.Configure<SessionSecurityOptions>(options => { options.SessionTimeout = TimeSpan.FromHours(2); options.RequireHttps = true; options.SecureSessionTokens = true; options.EnableRateLimiting = true; }); } } Security Testing Penetration Testing: Regular security assessments Code Security Reviews: Static analysis for vulnerabilities Dependency Scanning: Third-party library security checks Authentication Testing: Session security validation For implementation details, see Database Schema and SignalR Integration"
  },
  "articles/technical/signalr-integration.html": {
    "href": "articles/technical/signalr-integration.html",
    "title": "SignalR Integration Guide | NOOR CANVAS Documentation",
    "summary": "SignalR Integration Guide Overview NOOR CANVAS uses SignalR for real-time communication, enabling live collaboration, annotation synchronization, and instant participant feedback. Hub Architecture Core SignalR Hubs SessionHub - Session Management public class SessionHub : Hub { public async Task JoinSession(string sessionId) { await Groups.AddToGroupAsync(Context.ConnectionId, $\"session_{sessionId}\"); await Clients.Group($\"session_{sessionId}\").SendAsync(\"UserJoined\", Context.ConnectionId); } public async Task LeaveSession(string sessionId) { await Groups.RemoveFromGroupAsync(Context.ConnectionId, $\"session_{sessionId}\"); await Clients.Group($\"session_{sessionId}\").SendAsync(\"UserLeft\", Context.ConnectionId); } } AnnotationHub - Real-time Drawing public class AnnotationHub : Hub { public async Task SendAnnotation(string sessionId, AnnotationData data) { await Clients.Group($\"session_{sessionId}\").SendAsync(\"ReceiveAnnotation\", data); } public async Task ClearCanvas(string sessionId) { await Clients.Group($\"session_{sessionId}\").SendAsync(\"CanvasCleared\"); } } Client-Side Integration Blazor Server Connection Connection Establishment const connection = new signalR.HubConnectionBuilder() .withUrl(\"/hub/session\") .configureLogging(signalR.LogLevel.Information) .build(); // Start connection await connection.start(); Real-time Event Handling // Listen for annotation updates connection.on(\"ReceiveAnnotation\", function (data) { renderAnnotation(data); updateCanvas(data); }); // Handle participant changes connection.on(\"UserJoined\", function (connectionId) { updateParticipantList(); showNotification(\"New participant joined\"); }); Performance Optimizations Connection Management Connection Pooling: Efficient connection reuse Automatic Reconnection: Handles network interruptions Heartbeat Monitoring: Connection health checks Graceful Degradation: Fallback mechanisms Message Optimization // Efficient message structure public class AnnotationData { public string Type { get; set; } // draw, erase, clear public int[] Coordinates { get; set; } // compressed coordinates public string Color { get; set; } // hex color code public int Thickness { get; set; } // line thickness public long Timestamp { get; set; } // client timestamp } Scalability Features Group Management: Session-based message routing Message Compression: Reduced bandwidth usage Client-side Caching: Optimized rendering Selective Updates: Only send necessary changes Security Implementation Connection Authentication public class SessionHub : Hub { public override async Task OnConnectedAsync() { var sessionId = Context.GetHttpContext()?.Request.Query[\"sessionId\"]; var isValidSession = await ValidateSessionAccess(sessionId); if (!isValidSession) { Context.Abort(); return; } await base.OnConnectedAsync(); } } Message Validation Input Sanitization: All messages validated Rate Limiting: Prevents spam and abuse Session Verification: Ensures user belongs to session Data Encryption: Secure message transmission Error Handling Connection Errors connection.onclose(async () => { console.log(\"Connection closed. Attempting to reconnect...\"); await startConnection(); }); connection.onreconnecting(() => { console.log(\"Attempting to reconnect...\"); showConnectionStatus(\"Reconnecting...\"); }); connection.onreconnected(() => { console.log(\"Successfully reconnected.\"); showConnectionStatus(\"Connected\"); }); Server-side Error Handling public class AnnotationHub : Hub { public async Task SendAnnotation(string sessionId, AnnotationData data) { try { await ValidateAnnotationData(data); await SaveAnnotation(sessionId, data); await Clients.Group($\"session_{sessionId}\").SendAsync(\"ReceiveAnnotation\", data); } catch (Exception ex) { _logger.LogError(ex, \"Failed to process annotation for session {SessionId}\", sessionId); await Clients.Caller.SendAsync(\"AnnotationError\", \"Failed to process annotation\"); } } } Configuration Startup Configuration // Program.cs builder.Services.AddSignalR(options => { options.EnableDetailedErrors = builder.Environment.IsDevelopment(); options.HandshakeTimeout = TimeSpan.FromSeconds(15); options.KeepAliveInterval = TimeSpan.FromSeconds(15); options.ClientTimeoutInterval = TimeSpan.FromSeconds(30); }); // Configure endpoints app.MapHub<SessionHub>(\"/hub/session\"); app.MapHub<AnnotationHub>(\"/hub/annotation\"); app.MapHub<ParticipantHub>(\"/hub/participant\"); app.MapHub<QuestionHub>(\"/hub/question\"); Client Configuration const connection = new signalR.HubConnectionBuilder() .withUrl(\"/hub/session\", { transport: signalR.HttpTransportType.WebSockets | signalR.HttpTransportType.LongPolling }) .withAutomaticReconnect([0, 2000, 10000, 30000]) .configureLogging(signalR.LogLevel.Information) .build(); Testing SignalR Integration Unit Testing Hubs [Test] public async Task SessionHub_JoinSession_AddsToGroup() { // Arrange var hub = new SessionHub(); var context = CreateMockHubContext(); hub.Context = context; // Act await hub.JoinSession(\"test-session\"); // Assert VerifyGroupMembership(\"session_test-session\", context.ConnectionId); } Integration Testing [Test] public async Task SignalR_AnnotationFlow_WorksEndToEnd() { // Test full annotation workflow var connection = await CreateTestConnection(); var annotation = CreateTestAnnotation(); await connection.InvokeAsync(\"SendAnnotation\", \"test-session\", annotation); var receivedAnnotation = await WaitForAnnotation(); Assert.AreEqual(annotation.Data, receivedAnnotation.Data); } For more implementation details, see Getting Started Guide"
  },
  "index.html": {
    "href": "index.html",
    "title": "NOOR CANVAS Documentation | NOOR CANVAS Documentation",
    "summary": "NOOR CANVAS Documentation Welcome to the NOOR CANVAS Islamic Content Sharing Platform documentation. Overview NOOR CANVAS is a real-time Islamic content sharing platform built with ASP.NET Core 8.0 and Blazor Server, featuring: Real-time Annotations: Live drawing and annotation capabilities using SignalR Session Management: Host-controlled sessions with participant management Islamic Content Integration: Support for Qur'an, Hadith, Etymology, and Islamic Poetry Multi-language Support: Arabic (RTL), English (LTR), and Urdu (RTL) McBeatch Theme: Beautiful, responsive UI with multiple color variants Documentation Sections API Reference Complete API documentation for all controllers, services, models, and hubs. Technical Architecture Detailed technical architecture including: ASP.NET Core 8.0 structure SignalR real-time communication Entity Framework Core data layer Database schema (canvas + dbo integration) Development Guide Development environment setup and workflow: Project setup and configuration Development server (IIS Express x64) Database configuration Testing framework Deployment Guide Production deployment instructions: IIS production configuration Database migration Security considerations Performance optimization User Guides End-user documentation: Host session management Participant interaction Annotation tools Q&A system Getting Started Review the Technical Architecture Set up your Development Environment Explore the API Reference Follow the Implementation Phases Project Information Version: Phase 4 (Content & Styling) Framework: ASP.NET Core 8.0, Blazor Server Database: SQL Server with canvas schema Real-time: SignalR WebSocket communication Theme: McBeatch responsive design Timeline: 20-week phased implementation Last Updated: September 13, 2025"
  }
}