<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>

  <head>
    <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
      <title>Automated Testing Technical Reference </title>
      <meta name="viewport" content="width=device-width">
      <meta name="title" content="Automated Testing Technical Reference ">
    
    
      <link rel="shortcut icon" href="../../favicon.ico">
      <link rel="stylesheet" href="../../styles/docfx.vendor.min.css">
      <link rel="stylesheet" href="../../styles/docfx.css">
      <link rel="stylesheet" href="../../styles/main.css">
      <meta property="docfx:navrel" content="../../toc.html">
      <meta property="docfx:tocrel" content="toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>

        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>

              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>

        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">

        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="automated-testing-technical-reference">Automated Testing Technical Reference</h1>

<h2 id="architecture-overview">Architecture Overview</h2>
<p>The NOOR Canvas automated testing system provides comprehensive test automation through a multi-layered approach combining build integration, Git hooks, and intelligent caching. The system is designed to maximize code quality while minimizing developer friction.</p>
<h2 id="core-components">Core Components</h2>
<h3 id="1-post-build-test-integration">1. Post-Build Test Integration</h3>
<p><strong>Implementation</strong>: <code>.hooks/post-build.ps1</code></p>
<p>The post-build testing system automatically executes tests after successful compilation, using build artifact hashing to determine when tests are needed.</p>
<pre><code class="lang-powershell"># Core build artifact detection
function Get-BuildArtifactHash {
    param([string]$Configuration = &quot;Debug&quot;)
    
    $artifactPaths = @(
        &quot;SPA\NoorCanvas\bin\$Configuration\net8.0\*.dll&quot;,
        &quot;SPA\NoorCanvas\bin\$Configuration\net8.0\*.exe&quot;
    )
    
    $files = Get-ChildItem $artifactPaths -ErrorAction SilentlyContinue
    if (-not $files) { return $null }
    
    $hashInput = ($files | ForEach-Object { 
        &quot;$($_.Name):$($_.LastWriteTime.Ticks):$($_.Length)&quot; 
    }) -join &quot;|&quot;
    
    return [System.Security.Cryptography.SHA256]::Create().ComputeHash([System.Text.Encoding]::UTF8.GetBytes($hashInput)) | ForEach-Object { $_.ToString(&quot;x2&quot;) } | Join-String
}

# Cache management
$cacheDir = &quot;.build-cache&quot;
$lastHashFile = Join-Path $cacheDir &quot;last-build-hash.txt&quot;

$currentHash = Get-BuildArtifactHash -Configuration $Configuration
$lastHash = if (Test-Path $lastHashFile) { Get-Content $lastHashFile -Raw } else { &quot;&quot; }

if ($currentHash -eq $lastHash -and -not $Force) {
    Write-Host &quot;‚ö° Tests skipped - build artifacts unchanged&quot; -ForegroundColor Yellow
    return 0
}
</code></pre>
<h3 id="2-pre-commit-test-validation">2. Pre-Commit Test Validation</h3>
<p><strong>Implementation</strong>: <code>.hooks/pre-commit-test.ps1</code> + Git pre-commit hook</p>
<p>Pre-commit testing prevents broken code from entering the repository by validating all changes before commits are accepted.</p>
<pre><code class="lang-powershell"># Source code hash calculation
function Get-SourceCodeHash {
    $sourceExtensions = @(&quot;*.cs&quot;, &quot;*.cshtml&quot;, &quot;*.razor&quot;, &quot;*.js&quot;, &quot;*.ts&quot;)
    $excludePaths = @(&quot;bin&quot;, &quot;obj&quot;, &quot;node_modules&quot;, &quot;.git&quot;, &quot;_site&quot;)
    
    $allFiles = @()
    foreach ($ext in $sourceExtensions) {
        $files = Get-ChildItem -Recurse -Include $ext -ErrorAction SilentlyContinue |
                Where-Object { 
                    $path = $_.FullName
                    -not ($excludePaths | Where-Object { $path -like &quot;*\$_\*&quot; })
                }
        $allFiles += $files
    }
    
    if (-not $allFiles) { return &quot;&quot; }
    
    # Create deterministic hash from file contents and paths
    $hashInput = ($allFiles | Sort-Object FullName | ForEach-Object {
        $relativePath = $_.FullName -replace [Regex]::Escape((Get-Location).Path), &quot;&quot;
        $content = Get-Content $_.FullName -Raw -ErrorAction SilentlyContinue
        &quot;$relativePath|$($_.LastWriteTime.Ticks)|$($content.GetHashCode())&quot;
    }) -join &quot;`n&quot;
    
    $hasher = [System.Security.Cryptography.SHA256]::Create()
    $hashBytes = $hasher.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($hashInput))
    return [System.BitConverter]::ToString($hashBytes) -replace '-', ''
}

# Git hook integration
$hookPath = &quot;.git\hooks\pre-commit&quot;
if (-not (Test-Path $hookPath)) {
    Write-Host &quot;‚ö†Ô∏è  Installing Git pre-commit hook...&quot; -ForegroundColor Yellow
    Install-GitHook
}
</code></pre>
<h3 id="3-smart-caching-system">3. Smart Caching System</h3>
<p>The caching system prevents redundant test execution while ensuring comprehensive validation.</p>
<h4 id="cache-architecture">Cache Architecture</h4>
<pre><code>.test-cache/                    # Pre-commit test cache
‚îú‚îÄ‚îÄ last-test-hash.txt         # SHA256 of source files from last test
‚îú‚îÄ‚îÄ last-test-result.txt       # PASS/FAIL status of last test
‚îî‚îÄ‚îÄ last-test-timestamp.txt    # When tests were last executed

.build-cache/                   # Post-build test cache  
‚îú‚îÄ‚îÄ last-build-hash.txt        # SHA256 of build artifacts
‚îî‚îÄ‚îÄ last-build-timestamp.txt   # When build tests were last run
</code></pre>
<h4 id="cache-validation-logic">Cache Validation Logic</h4>
<pre><code class="lang-powershell">function Test-CacheValid {
    param(
        [string]$CurrentHash,
        [string]$CacheType = &quot;test&quot;
    )
    
    $cacheDir = &quot;.$CacheType-cache&quot;
    $hashFile = Join-Path $cacheDir &quot;last-$CacheType-hash.txt&quot;
    $resultFile = Join-Path $cacheDir &quot;last-$CacheType-result.txt&quot;
    
    # Cache is valid if:
    # 1. Hash file exists and matches current hash
    # 2. Result file exists and shows PASS
    # 3. Cache timestamp is recent (within 24 hours)
    
    if (-not (Test-Path $hashFile) -or -not (Test-Path $resultFile)) {
        return $false
    }
    
    $cachedHash = Get-Content $hashFile -Raw
    $cachedResult = Get-Content $resultFile -Raw
    
    return ($cachedHash -eq $CurrentHash) -and ($cachedResult -eq &quot;PASS&quot;)
}

function Update-TestCache {
    param(
        [string]$Hash,
        [string]$Result,
        [string]$CacheType = &quot;test&quot;
    )
    
    $cacheDir = &quot;.$CacheType-cache&quot;
    if (-not (Test-Path $cacheDir)) {
        New-Item -ItemType Directory -Path $cacheDir -Force | Out-Null
    }
    
    Set-Content -Path (Join-Path $cacheDir &quot;last-$CacheType-hash.txt&quot;) -Value $Hash
    Set-Content -Path (Join-Path $cacheDir &quot;last-$CacheType-result.txt&quot;) -Value $Result
    Set-Content -Path (Join-Path $cacheDir &quot;last-$CacheType-timestamp.txt&quot;) -Value (Get-Date -Format &quot;o&quot;)
}
</code></pre>
<h3 id="4-test-execution-engine">4. Test Execution Engine</h3>
<h4 id="test-discovery-and-execution">Test Discovery and Execution</h4>
<pre><code class="lang-powershell">function Invoke-TestSuite {
    param(
        [string]$Configuration = &quot;Debug&quot;,
        [switch]$Verbose
    )
    
    $testProjects = @(
        &quot;Tests\NoorCanvas.Core.Tests\NoorCanvas.Core.Tests.csproj&quot;,
        &quot;Tests\NC-ImplementationTests\NC-ImplementationTests.csproj&quot;
    )
    
    $totalTests = 0
    $passedTests = 0
    $failedTests = 0
    
    foreach ($project in $testProjects) {
        if (Test-Path $project) {
            Write-Host &quot;üß™ Running tests: $(Split-Path $project -Leaf)&quot; -ForegroundColor Cyan
            
            $testArgs = @(
                &quot;test&quot;, $project,
                &quot;--configuration&quot;, $Configuration,
                &quot;--no-build&quot;,
                &quot;--logger&quot;, &quot;console;verbosity=minimal&quot;
            )
            
            if ($Verbose) {
                $testArgs += &quot;--logger&quot;, &quot;console;verbosity=detailed&quot;
            }
            
            $testResult = &amp; dotnet $testArgs 2&gt;&amp;1
            $testExitCode = $LASTEXITCODE
            
            # Parse test results
            $resultMatch = $testResult | Select-String &quot;Total tests: (\d+). Passed: (\d+). Failed: (\d+)&quot;
            if ($resultMatch) {
                $total = [int]$resultMatch.Matches[0].Groups[1].Value
                $passed = [int]$resultMatch.Matches[0].Groups[2].Value  
                $failed = [int]$resultMatch.Matches[0].Groups[3].Value
                
                $totalTests += $total
                $passedTests += $passed
                $failedTests += $failed
            }
            
            if ($testExitCode -ne 0) {
                Write-Host &quot;‚ùå Tests failed in $project&quot; -ForegroundColor Red
                if ($Verbose) {
                    Write-Host $testResult -ForegroundColor Gray
                }
            }
        }
    }
    
    # Summary reporting
    if ($failedTests -gt 0) {
        Write-Host &quot;‚ùå Test Summary: $passedTests passed, $failedTests failed ($totalTests total)&quot; -ForegroundColor Red
        return 1
    } else {
        Write-Host &quot;‚úÖ Test Summary: All $passedTests tests passed&quot; -ForegroundColor Green
        return 0
    }
}
</code></pre>
<h3 id="5-git-hook-integration">5. Git Hook Integration</h3>
<h4 id="pre-commit-hook-implementation">Pre-Commit Hook Implementation</h4>
<pre><code class="lang-bash">#!/bin/sh
# .git/hooks/pre-commit

# Execute PowerShell pre-commit tests
if command -v pwsh &gt;/dev/null 2&gt;&amp;1; then
    pwsh -ExecutionPolicy Bypass -File &quot;.hooks/pre-commit-test.ps1&quot;
elif command -v powershell &gt;/dev/null 2&gt;&amp;1; then
    powershell -ExecutionPolicy Bypass -File &quot;.hooks/pre-commit-test.ps1&quot;
else
    echo &quot;‚ùå PowerShell not found - cannot run pre-commit tests&quot;
    exit 1
fi

exit $?
</code></pre>
<h4 id="hook-installation-and-management">Hook Installation and Management</h4>
<pre><code class="lang-powershell">function Install-GitHook {
    param([string]$HookType = &quot;pre-commit&quot;)
    
    $hooksDir = &quot;.git\hooks&quot;
    $hookPath = Join-Path $hooksDir $HookType
    
    if (-not (Test-Path $hooksDir)) {
        Write-Error &quot;Not in a Git repository (.git/hooks not found)&quot;
        return $false
    }
    
    $hookContent = @&quot;
#!/bin/sh
# Auto-generated NOOR Canvas $HookType hook

if command -v pwsh &gt;/dev/null 2&gt;&amp;1; then
    pwsh -ExecutionPolicy Bypass -File &quot;.hooks/$HookType-test.ps1&quot;
elif command -v powershell &gt;/dev/null 2&gt;&amp;1; then  
    powershell -ExecutionPolicy Bypass -File &quot;.hooks/$HookType-test.ps1&quot;
else
    echo &quot;‚ùå PowerShell not found - cannot run $HookType tests&quot;
    exit 1
fi

exit $?
&quot;@
    
    Set-Content -Path $hookPath -Value $hookContent -Encoding ASCII
    
    # Make executable on Unix systems
    if ($IsLinux -or $IsMacOS) {
        chmod +x $hookPath
    }
    
    Write-Host &quot;‚úÖ Installed Git $HookType hook&quot; -ForegroundColor Green
    return $true
}

function Remove-GitHook {
    param([string]$HookType = &quot;pre-commit&quot;)
    
    $hookPath = &quot;.git\hooks\$HookType&quot;
    if (Test-Path $hookPath) {
        Remove-Item $hookPath -Force
        Write-Host &quot;‚úÖ Removed Git $HookType hook&quot; -ForegroundColor Green
    }
}
</code></pre>
<h3 id="6-vs-code-integration">6. VS Code Integration</h3>
<h4 id="task-configuration">Task Configuration</h4>
<pre><code class="lang-json">{
    &quot;version&quot;: &quot;2.0.0&quot;,
    &quot;tasks&quot;: [
        {
            &quot;label&quot;: &quot;build-with-tests&quot;,
            &quot;type&quot;: &quot;process&quot;,
            &quot;command&quot;: &quot;dotnet&quot;,
            &quot;args&quot;: [
                &quot;build&quot;,
                &quot;${workspaceFolder}/SPA/NoorCanvas/NoorCanvas.csproj&quot;
            ],
            &quot;group&quot;: {
                &quot;kind&quot;: &quot;build&quot;,
                &quot;isDefault&quot;: true
            },
            &quot;dependsOn&quot;: &quot;run-post-build-tests&quot;,
            &quot;presentation&quot;: {
                &quot;echo&quot;: true,
                &quot;reveal&quot;: &quot;always&quot;,
                &quot;focus&quot;: false,
                &quot;panel&quot;: &quot;shared&quot;
            }
        },
        {
            &quot;label&quot;: &quot;run-post-build-tests&quot;,
            &quot;type&quot;: &quot;shell&quot;, 
            &quot;command&quot;: &quot;powershell.exe&quot;,
            &quot;args&quot;: [
                &quot;-NoProfile&quot;,
                &quot;-ExecutionPolicy&quot;, &quot;Bypass&quot;,
                &quot;-File&quot;, &quot;${workspaceFolder}/.hooks/post-build.ps1&quot;,
                &quot;-Configuration&quot;, &quot;Debug&quot;
            ],
            &quot;group&quot;: &quot;test&quot;,
            &quot;presentation&quot;: {
                &quot;echo&quot;: false,
                &quot;reveal&quot;: &quot;always&quot;, 
                &quot;focus&quot;: false,
                &quot;panel&quot;: &quot;shared&quot;
            }
        }
    ]
}
</code></pre>
<h3 id="7-performance-optimization">7. Performance Optimization</h3>
<h4 id="parallel-test-execution">Parallel Test Execution</h4>
<pre><code class="lang-powershell">function Invoke-ParallelTests {
    param([string[]]$TestProjects)
    
    $jobs = @()
    
    foreach ($project in $TestProjects) {
        $job = Start-Job -ScriptBlock {
            param($ProjectPath)
            
            $result = &amp; dotnet test $ProjectPath --logger &quot;console;verbosity=minimal&quot; 2&gt;&amp;1
            return @{
                Project = $ProjectPath
                ExitCode = $LASTEXITCODE
                Output = $result
            }
        } -ArgumentList $project
        
        $jobs += $job
    }
    
    # Wait for all tests to complete
    $results = $jobs | Wait-Job | Receive-Job
    $jobs | Remove-Job
    
    return $results
}
</code></pre>
<h4 id="incremental-testing">Incremental Testing</h4>
<pre><code class="lang-powershell">function Get-ChangedTestProjects {
    param([string[]]$ChangedFiles)
    
    $testProjects = @()
    
    foreach ($file in $ChangedFiles) {
        # Determine which test projects need to run based on changed files
        switch -Regex ($file) {
            &quot;Controllers/&quot; { $testProjects += &quot;Tests\NoorCanvas.Core.Tests&quot; }
            &quot;Models/&quot; { $testProjects += &quot;Tests\NoorCanvas.Core.Tests&quot; }
            &quot;Services/&quot; { $testProjects += &quot;Tests\NoorCanvas.Core.Tests&quot; }
            &quot;Tools/HostProvisioner/&quot; { $testProjects += &quot;Tests\NC-ImplementationTests&quot; }
        }
    }
    
    return $testProjects | Sort-Object -Unique
}
</code></pre>
<h3 id="8-error-handling-and-recovery">8. Error Handling and Recovery</h3>
<h4 id="test-failure-analysis">Test Failure Analysis</h4>
<pre><code class="lang-powershell">function Analyze-TestFailures {
    param([string]$TestOutput)
    
    $failures = @()
    
    # Parse common failure patterns
    $patterns = @{
        &quot;DatabaseConnection&quot; = &quot;.*connection.*timeout.*|.*cannot connect.*database.*&quot;
        &quot;ApiEndpoint&quot; = &quot;.*HTTP.*404.*|.*endpoint.*not found.*&quot;
        &quot;SignalR&quot; = &quot;.*SignalR.*connection.*failed.*|.*hub.*not available.*&quot;
        &quot;Authentication&quot; = &quot;.*unauthorized.*|.*token.*invalid.*&quot;
    }
    
    foreach ($category in $patterns.Keys) {
        if ($TestOutput -match $patterns[$category]) {
            $failures += @{
                Category = $category
                Pattern = $patterns[$category]
                Suggestion = Get-FailureSuggestion -Category $category
            }
        }
    }
    
    return $failures
}

function Get-FailureSuggestion {
    param([string]$Category)
    
    switch ($Category) {
        &quot;DatabaseConnection&quot; { 
            return &quot;Check database server status and connection strings in appsettings.json&quot;
        }
        &quot;ApiEndpoint&quot; {
            return &quot;Verify API controller routes and ensure application is running&quot;
        }
        &quot;SignalR&quot; {
            return &quot;Check SignalR hub registration and WebSocket configuration&quot;
        }
        &quot;Authentication&quot; {
            return &quot;Regenerate host tokens using 'nct' command&quot;
        }
        default {
            return &quot;Review test output and check recent code changes&quot;
        }
    }
}
</code></pre>
<h4 id="automatic-recovery-mechanisms">Automatic Recovery Mechanisms</h4>
<pre><code class="lang-powershell">function Invoke-TestRecovery {
    param([string]$FailureCategory)
    
    switch ($FailureCategory) {
        &quot;DatabaseConnection&quot; {
            Write-Host &quot;üîÑ Attempting database recovery...&quot; -ForegroundColor Yellow
            
            # Test database connectivity
            $connectionTest = Test-DatabaseConnection
            if (-not $connectionTest) {
                Write-Host &quot;üí° Try: Restart SQL Server service or check connection string&quot; -ForegroundColor Cyan
            }
        }
        
        &quot;ApiEndpoint&quot; {
            Write-Host &quot;üîÑ Attempting application restart...&quot; -ForegroundColor Yellow
            
            # Kill existing processes and restart
            &amp; iiskill
            Start-Sleep -Seconds 3
            &amp; nc -SkipTokenGeneration
        }
        
        &quot;Authentication&quot; {
            Write-Host &quot;üîÑ Regenerating authentication tokens...&quot; -ForegroundColor Yellow
            
            # Generate new tokens
            &amp; nct
        }
    }
}
</code></pre>
<h3 id="9-reporting-and-metrics">9. Reporting and Metrics</h3>
<h4 id="test-result-reporting">Test Result Reporting</h4>
<pre><code class="lang-powershell">function Generate-TestReport {
    param(
        [hashtable]$TestResults,
        [string]$OutputFormat = &quot;Console&quot;
    )
    
    switch ($OutputFormat) {
        &quot;Console&quot; {
            Write-TestConsoleReport -Results $TestResults
        }
        &quot;JUnit&quot; {
            Write-TestJUnitReport -Results $TestResults
        }
        &quot;Html&quot; {
            Write-TestHtmlReport -Results $TestResults
        }
    }
}

function Write-TestConsoleReport {
    param([hashtable]$Results)
    
    Write-Host &quot;`nüìä Test Execution Summary&quot; -ForegroundColor Cyan
    Write-Host &quot;‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê&quot; -ForegroundColor Cyan
    
    $total = $Results.Passed + $Results.Failed + $Results.Skipped
    $successRate = if ($total -gt 0) { [math]::Round(($Results.Passed / $total) * 100, 1) } else { 0 }
    
    Write-Host &quot;‚úÖ Passed: $($Results.Passed)&quot; -ForegroundColor Green
    Write-Host &quot;‚ùå Failed: $($Results.Failed)&quot; -ForegroundColor Red
    Write-Host &quot;‚è≠Ô∏è  Skipped: $($Results.Skipped)&quot; -ForegroundColor Yellow
    Write-Host &quot;üìà Success Rate: $successRate%&quot; -ForegroundColor Cyan
    Write-Host &quot;‚è±Ô∏è  Duration: $($Results.Duration)&quot; -ForegroundColor Gray
}
</code></pre>
<h4 id="performance-metrics-collection">Performance Metrics Collection</h4>
<pre><code class="lang-powershell">function Collect-TestMetrics {
    param([hashtable]$TestResults)
    
    $metrics = @{
        Timestamp = Get-Date -Format &quot;o&quot;
        TestCount = $TestResults.Passed + $TestResults.Failed
        SuccessRate = ($TestResults.Passed / ($TestResults.Passed + $TestResults.Failed)) * 100
        Duration = $TestResults.Duration
        CacheHitRate = $TestResults.CacheHits / $TestResults.TotalRuns * 100
        FailureCategories = $TestResults.FailureCategories
    }
    
    # Store metrics for trending analysis
    $metricsFile = &quot;.test-cache\metrics.json&quot;
    $allMetrics = if (Test-Path $metricsFile) { 
        Get-Content $metricsFile | ConvertFrom-Json 
    } else { @() }
    
    $allMetrics += $metrics
    
    # Keep only last 100 entries
    if ($allMetrics.Count -gt 100) {
        $allMetrics = $allMetrics[-100..-1]
    }
    
    $allMetrics | ConvertTo-Json -Depth 3 | Set-Content $metricsFile
}
</code></pre>
<h2 id="configuration-and-customization">Configuration and Customization</h2>
<h3 id="test-configuration-files">Test Configuration Files</h3>
<pre><code class="lang-powershell"># .hooks/test-config.json
{
    &quot;testProjects&quot;: [
        &quot;Tests/NoorCanvas.Core.Tests/NoorCanvas.Core.Tests.csproj&quot;,
        &quot;Tests/NC-ImplementationTests/NC-ImplementationTests.csproj&quot;
    ],
    &quot;cacheDuration&quot;: &quot;24:00:00&quot;,
    &quot;parallelExecution&quot;: true,
    &quot;maxRetries&quot;: 3,
    &quot;timeoutMinutes&quot;: 10,
    &quot;reportFormats&quot;: [&quot;console&quot;, &quot;junit&quot;],
    &quot;excludePatterns&quot;: [
        &quot;**/bin/**&quot;,
        &quot;**/obj/**&quot;,
        &quot;**/.git/**&quot;
    ]
}
</code></pre>
<h3 id="environment-specific-settings">Environment-Specific Settings</h3>
<pre><code class="lang-powershell">function Get-TestConfiguration {
    param([string]$Environment = &quot;Development&quot;)
    
    $configs = @{
        &quot;Development&quot; = @{
            DatabaseTimeout = 30
            ParallelTests = $true
            VerboseOutput = $true
            CachingEnabled = $true
        }
        &quot;CI&quot; = @{
            DatabaseTimeout = 60
            ParallelTests = $true
            VerboseOutput = $false
            CachingEnabled = $false
        }
        &quot;Production&quot; = @{
            DatabaseTimeout = 120
            ParallelTests = $false
            VerboseOutput = $false
            CachingEnabled = $false
        }
    }
    
    return $configs[$Environment]
}
</code></pre>
<p>For user-friendly information about using the automated testing system, see the <a href="../user-guides/automated-testing-user-guide.html">Automated Testing User Guide</a>.</p>

</article>
          </div>

          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/asifhussain60/NOOR-CANVAS/blob/master/DocFX/articles/technical/automated-testing-technical-reference.md/#L1" class="contribution-link">Edit this page</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In this article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>

      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
      
      <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>

    <script type="text/javascript" src="../../styles/docfx.vendor.min.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
